--- tar-1.17/src/list.c	2007-06-08 16:14:42.000000000 +0800
+++ tar-CVE/src/list.c	2022-04-26 22:08:02.521627349 +0800
@@ -297,24 +297,26 @@
   union block *header;
-  union block *header_copy;
   char *bp;
   union block *data_block;
   size_t size, written;
-  union block *next_long_name = 0;
-  union block *next_long_link = 0;
+  union block *next_long_name = NULL;
+  union block *next_long_link = NULL;
   size_t next_long_name_blocks;
   size_t next_long_link_blocks;
 
+  enum read_header status = HEADER_SUCCESS;
+
   while (1)
     {
-      enum read_header status;
-
       header = find_next_block ();
       current_header = header;
       if (!header)
-	return HEADER_END_OF_FILE;
+      {
+          status = HEADER_END_OF_FILE;
+          break;
+      }
 
       if ((status = tar_checksum (header, false)) != HEADER_SUCCESS)
-	return status;
+          break;
 
       /* Good block.  Decode file size and return.  */
 
@@ -330,10 +332,14 @@
 	  || header->header.typeflag == SOLARIS_XHDTYPE)
 	{
 	  if (raw_extended_headers)
-	    return HEADER_SUCCESS_EXTENDED;
+      {
+        status = HEADER_SUCCESS_EXTENDED;
+        break;
+      }
 	  else if (header->header.typeflag == GNUTYPE_LONGNAME
 		   || header->header.typeflag == GNUTYPE_LONGLINK)
 	    {
+          union block *header_copy;
 	      size_t name_size = info->stat.st_size;
 	      size_t n = name_size % BLOCKSIZE;
 	      size = name_size + BLOCKSIZE;
@@ -415,6 +421,7 @@
 	      name = next_long_name->buffer + BLOCKSIZE;
 	      recent_long_name = next_long_name;
 	      recent_long_name_blocks = next_long_name_blocks;
+          next_long_name = NULL;
 	    }
 	  else
 	    {
@@ -447,6 +454,7 @@
 	      name = next_long_link->buffer + BLOCKSIZE;
 	      recent_long_link = next_long_link;
 	      recent_long_link_blocks = next_long_link_blocks;
+          next_long_link = NULL;
 	    }
 	  else
 	    {
@@ -458,9 +466,12 @@
 	    }
 	  assign_string (&info->link_name, name);
 
-	  return HEADER_SUCCESS;
+      break;
 	}
     }
+  free(next_long_name);
+  free(next_long_link);
+  return status;
 }
 
 enum read_header
