diff -Naru freetype-2.10.4-org/include/freetype/ftmemory.h freetype-2.10.4/include/freetype/ftmemory.h
--- freetype-2.10.4-org/include/freetype/ftmemory.h	1970-01-01 08:00:00.000000000 +0800
+++ freetype-2.10.4/include/freetype/ftmemory.h	2020-11-29 20:53:50.652581392 +0800
@@ -0,0 +1,399 @@
+/****************************************************************************
+ *
+ *  Important: Should copy this file to include/freetype/ directory,
+ *  Otherwise, these API can't use outside.(symbol is t)
+ *  add this step, we can use these APIS outside.(symbol is T)
+ *
+ * ftmemory.h
+ *
+ *   The FreeType memory management macros (specification).
+ *
+ * Copyright (C) 1996-2020 by
+ * David Turner, Robert Wilhelm, and Werner Lemberg
+ *
+ * This file is part of the FreeType project, and may only be used,
+ * modified, and distributed under the terms of the FreeType project
+ * license, LICENSE.TXT.  By continuing to use, modify, or distribute
+ * this file you indicate that you have read the license and
+ * understand and accept it fully.
+ *
+ */
+
+
+#ifndef FTMEMORY_H_
+#define FTMEMORY_H_
+
+
+#include <ft2build.h>
+#include FT_CONFIG_CONFIG_H
+#include <freetype/fttypes.h>
+
+#include "compiler-macros.h"
+
+FT_BEGIN_HEADER
+
+
+  /**************************************************************************
+   *
+   * @macro:
+   *   FT_SET_ERROR
+   *
+   * @description:
+   *   This macro is used to set an implicit 'error' variable to a given
+   *   expression's value (usually a function call), and convert it to a
+   *   boolean which is set whenever the value is != 0.
+   */
+#undef  FT_SET_ERROR
+#define FT_SET_ERROR( expression ) \
+          ( ( error = (expression) ) != 0 )
+
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+  /****                                                                 ****/
+  /****                                                                 ****/
+  /****                           M E M O R Y                           ****/
+  /****                                                                 ****/
+  /****                                                                 ****/
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  /* The calculation `NULL + n' is undefined in C.  Even if the resulting */
+  /* pointer doesn't get dereferenced, this causes warnings with          */
+  /* sanitizers.                                                          */
+  /*                                                                      */
+  /* We thus provide a macro that should be used if `base' can be NULL.   */
+#define FT_OFFSET( base, count )  ( (base) ? (base) + (count) : NULL )
+
+
+  /*
+   * C++ refuses to handle statements like p = (void*)anything, with `p' a
+   * typed pointer.  Since we don't have a `typeof' operator in standard C++,
+   * we have to use a template to emulate it.
+   */
+
+#ifdef __cplusplus
+
+extern "C++"
+{
+  template <typename T> inline T*
+  cplusplus_typeof(        T*,
+                    void  *v )
+  {
+    return static_cast <T*> ( v );
+  }
+}
+
+#define FT_ASSIGNP( p, val )  (p) = cplusplus_typeof( (p), (val) )
+
+#else
+
+#define FT_ASSIGNP( p, val )  (p) = (val)
+
+#endif
+
+
+
+#ifdef FT_DEBUG_MEMORY
+
+  FT_BASE( const char* )  _ft_debug_file;
+  FT_BASE( long )         _ft_debug_lineno;
+
+#define FT_DEBUG_INNER( exp )  ( _ft_debug_file   = __FILE__, \
+                                 _ft_debug_lineno = __LINE__, \
+                                 (exp) )
+
+#define FT_ASSIGNP_INNER( p, exp )  ( _ft_debug_file   = __FILE__, \
+                                      _ft_debug_lineno = __LINE__, \
+                                      FT_ASSIGNP( p, exp ) )
+
+#else /* !FT_DEBUG_MEMORY */
+
+#define FT_DEBUG_INNER( exp )       (exp)
+#define FT_ASSIGNP_INNER( p, exp )  FT_ASSIGNP( p, exp )
+
+#endif /* !FT_DEBUG_MEMORY */
+
+
+  /*
+   * The allocation functions return a pointer, and the error code is written
+   * to through the `p_error' parameter.
+   */
+
+  /* The `q' variants of the functions below (`q' for `quick') don't fill */
+  /* the allocated or reallocated memory with zero bytes.                 */
+
+  FT_EXPORT( FT_Pointer )
+  ft_mem_alloc( FT_Memory  memory,
+                FT_Long    size,
+                FT_Error  *p_error );
+
+  FT_EXPORT( FT_Pointer )
+  ft_mem_qalloc( FT_Memory  memory,
+                 FT_Long    size,
+                 FT_Error  *p_error );
+
+  FT_EXPORT( FT_Pointer )
+  ft_mem_realloc( FT_Memory  memory,
+                  FT_Long    item_size,
+                  FT_Long    cur_count,
+                  FT_Long    new_count,
+                  void*      block,
+                  FT_Error  *p_error );
+
+  FT_EXPORT( FT_Pointer )
+  ft_mem_qrealloc( FT_Memory  memory,
+                   FT_Long    item_size,
+                   FT_Long    cur_count,
+                   FT_Long    new_count,
+                   void*      block,
+                   FT_Error  *p_error );
+
+  FT_EXPORT( void )
+  ft_mem_free( FT_Memory    memory,
+               const void*  P );
+
+
+  /* The `Q' variants of the macros below (`Q' for `quick') don't fill */
+  /* the allocated or reallocated memory with zero bytes.              */
+
+#define FT_MEM_ALLOC( ptr, size )                               \
+          FT_ASSIGNP_INNER( ptr, ft_mem_alloc( memory,          \
+                                               (FT_Long)(size), \
+                                               &error ) )
+
+#define FT_MEM_FREE( ptr )                                  \
+          FT_BEGIN_STMNT                                    \
+            FT_DEBUG_INNER( ft_mem_free( memory, (ptr) ) ); \
+            (ptr) = NULL;                                   \
+          FT_END_STMNT
+
+#define FT_MEM_NEW( ptr )                        \
+          FT_MEM_ALLOC( ptr, sizeof ( *(ptr) ) )
+
+#define FT_MEM_REALLOC( ptr, cursz, newsz )                        \
+          FT_ASSIGNP_INNER( ptr, ft_mem_realloc( memory,           \
+                                                 1,                \
+                                                 (FT_Long)(cursz), \
+                                                 (FT_Long)(newsz), \
+                                                 (ptr),            \
+                                                 &error ) )
+
+#define FT_MEM_QALLOC( ptr, size )                               \
+          FT_ASSIGNP_INNER( ptr, ft_mem_qalloc( memory,          \
+                                                (FT_Long)(size), \
+                                                &error ) )
+
+#define FT_MEM_QNEW( ptr )                        \
+          FT_MEM_QALLOC( ptr, sizeof ( *(ptr) ) )
+
+#define FT_MEM_QREALLOC( ptr, cursz, newsz )                        \
+          FT_ASSIGNP_INNER( ptr, ft_mem_qrealloc( memory,           \
+                                                  1,                \
+                                                  (FT_Long)(cursz), \
+                                                  (FT_Long)(newsz), \
+                                                  (ptr),            \
+                                                  &error ) )
+
+#define FT_MEM_ALLOC_MULT( ptr, count, item_size )                     \
+          FT_ASSIGNP_INNER( ptr, ft_mem_realloc( memory,               \
+                                                 (FT_Long)(item_size), \
+                                                 0,                    \
+                                                 (FT_Long)(count),     \
+                                                 NULL,                 \
+                                                 &error ) )
+
+#define FT_MEM_REALLOC_MULT( ptr, oldcnt, newcnt, itmsz )           \
+          FT_ASSIGNP_INNER( ptr, ft_mem_realloc( memory,            \
+                                                 (FT_Long)(itmsz),  \
+                                                 (FT_Long)(oldcnt), \
+                                                 (FT_Long)(newcnt), \
+                                                 (ptr),             \
+                                                 &error ) )
+
+#define FT_MEM_QALLOC_MULT( ptr, count, item_size )                     \
+          FT_ASSIGNP_INNER( ptr, ft_mem_qrealloc( memory,               \
+                                                  (FT_Long)(item_size), \
+                                                  0,                    \
+                                                  (FT_Long)(count),     \
+                                                  NULL,                 \
+                                                  &error ) )
+
+#define FT_MEM_QREALLOC_MULT( ptr, oldcnt, newcnt, itmsz )           \
+          FT_ASSIGNP_INNER( ptr, ft_mem_qrealloc( memory,            \
+                                                  (FT_Long)(itmsz),  \
+                                                  (FT_Long)(oldcnt), \
+                                                  (FT_Long)(newcnt), \
+                                                  (ptr),             \
+                                                  &error ) )
+
+
+#define FT_MEM_SET_ERROR( cond )  ( (cond), error != 0 )
+
+
+#define FT_MEM_SET( dest, byte, count )               \
+          ft_memset( dest, byte, (FT_Offset)(count) )
+
+#define FT_MEM_COPY( dest, source, count )              \
+          ft_memcpy( dest, source, (FT_Offset)(count) )
+
+#define FT_MEM_MOVE( dest, source, count )               \
+          ft_memmove( dest, source, (FT_Offset)(count) )
+
+
+#define FT_MEM_ZERO( dest, count )  FT_MEM_SET( dest, 0, count )
+
+#define FT_ZERO( p )                FT_MEM_ZERO( p, sizeof ( *(p) ) )
+
+
+#define FT_ARRAY_ZERO( dest, count )                             \
+          FT_MEM_ZERO( dest,                                     \
+                       (FT_Offset)(count) * sizeof ( *(dest) ) )
+
+#define FT_ARRAY_COPY( dest, source, count )                     \
+          FT_MEM_COPY( dest,                                     \
+                       source,                                   \
+                       (FT_Offset)(count) * sizeof ( *(dest) ) )
+
+#define FT_ARRAY_MOVE( dest, source, count )                     \
+          FT_MEM_MOVE( dest,                                     \
+                       source,                                   \
+                       (FT_Offset)(count) * sizeof ( *(dest) ) )
+
+
+  /*
+   * Return the maximum number of addressable elements in an array.  We limit
+   * ourselves to INT_MAX, rather than UINT_MAX, to avoid any problems.
+   */
+#define FT_ARRAY_MAX( ptr )           ( FT_INT_MAX / sizeof ( *(ptr) ) )
+
+#define FT_ARRAY_CHECK( ptr, count )  ( (count) <= FT_ARRAY_MAX( ptr ) )
+
+
+  /**************************************************************************
+   *
+   * The following functions macros expect that their pointer argument is
+   * _typed_ in order to automatically compute array element sizes.
+   */
+
+#define FT_MEM_NEW_ARRAY( ptr, count )                              \
+          FT_ASSIGNP_INNER( ptr, ft_mem_realloc( memory,            \
+                                                 sizeof ( *(ptr) ), \
+                                                 0,                 \
+                                                 (FT_Long)(count),  \
+                                                 NULL,              \
+                                                 &error ) )
+
+#define FT_MEM_RENEW_ARRAY( ptr, cursz, newsz )                     \
+          FT_ASSIGNP_INNER( ptr, ft_mem_realloc( memory,            \
+                                                 sizeof ( *(ptr) ), \
+                                                 (FT_Long)(cursz),  \
+                                                 (FT_Long)(newsz),  \
+                                                 (ptr),             \
+                                                 &error ) )
+
+#define FT_MEM_QNEW_ARRAY( ptr, count )                              \
+          FT_ASSIGNP_INNER( ptr, ft_mem_qrealloc( memory,            \
+                                                  sizeof ( *(ptr) ), \
+                                                  0,                 \
+                                                  (FT_Long)(count),  \
+                                                  NULL,              \
+                                                  &error ) )
+
+#define FT_MEM_QRENEW_ARRAY( ptr, cursz, newsz )                     \
+          FT_ASSIGNP_INNER( ptr, ft_mem_qrealloc( memory,            \
+                                                  sizeof ( *(ptr) ), \
+                                                  (FT_Long)(cursz),  \
+                                                  (FT_Long)(newsz),  \
+                                                  (ptr),             \
+                                                  &error ) )
+
+#define FT_ALLOC( ptr, size )                           \
+          FT_MEM_SET_ERROR( FT_MEM_ALLOC( ptr, size ) )
+
+#define FT_REALLOC( ptr, cursz, newsz )                           \
+          FT_MEM_SET_ERROR( FT_MEM_REALLOC( ptr, cursz, newsz ) )
+
+#define FT_ALLOC_MULT( ptr, count, item_size )                           \
+          FT_MEM_SET_ERROR( FT_MEM_ALLOC_MULT( ptr, count, item_size ) )
+
+#define FT_REALLOC_MULT( ptr, oldcnt, newcnt, itmsz )              \
+          FT_MEM_SET_ERROR( FT_MEM_REALLOC_MULT( ptr, oldcnt,      \
+                                                 newcnt, itmsz ) )
+
+#define FT_QALLOC( ptr, size )                           \
+          FT_MEM_SET_ERROR( FT_MEM_QALLOC( ptr, size ) )
+
+#define FT_QREALLOC( ptr, cursz, newsz )                           \
+          FT_MEM_SET_ERROR( FT_MEM_QREALLOC( ptr, cursz, newsz ) )
+
+#define FT_QALLOC_MULT( ptr, count, item_size )                           \
+          FT_MEM_SET_ERROR( FT_MEM_QALLOC_MULT( ptr, count, item_size ) )
+
+#define FT_QREALLOC_MULT( ptr, oldcnt, newcnt, itmsz )              \
+          FT_MEM_SET_ERROR( FT_MEM_QREALLOC_MULT( ptr, oldcnt,      \
+                                                  newcnt, itmsz ) )
+
+#define FT_FREE( ptr )  FT_MEM_FREE( ptr )
+
+#define FT_NEW( ptr )  FT_MEM_SET_ERROR( FT_MEM_NEW( ptr ) )
+
+#define FT_NEW_ARRAY( ptr, count )                           \
+          FT_MEM_SET_ERROR( FT_MEM_NEW_ARRAY( ptr, count ) )
+
+#define FT_RENEW_ARRAY( ptr, curcnt, newcnt )                           \
+          FT_MEM_SET_ERROR( FT_MEM_RENEW_ARRAY( ptr, curcnt, newcnt ) )
+
+#define FT_QNEW( ptr )                           \
+          FT_MEM_SET_ERROR( FT_MEM_QNEW( ptr ) )
+
+#define FT_QNEW_ARRAY( ptr, count )                          \
+          FT_MEM_SET_ERROR( FT_MEM_NEW_ARRAY( ptr, count ) )
+
+#define FT_QRENEW_ARRAY( ptr, curcnt, newcnt )                          \
+          FT_MEM_SET_ERROR( FT_MEM_RENEW_ARRAY( ptr, curcnt, newcnt ) )
+
+
+  FT_EXPORT( FT_Pointer )
+  ft_mem_strdup( FT_Memory    memory,
+                 const char*  str,
+                 FT_Error    *p_error );
+
+  FT_EXPORT( FT_Pointer )
+  ft_mem_dup( FT_Memory    memory,
+              const void*  address,
+              FT_ULong     size,
+              FT_Error    *p_error );
+
+
+#define FT_MEM_STRDUP( dst, str )                                            \
+          (dst) = (char*)ft_mem_strdup( memory, (const char*)(str), &error )
+
+#define FT_STRDUP( dst, str )                           \
+          FT_MEM_SET_ERROR( FT_MEM_STRDUP( dst, str ) )
+
+#define FT_MEM_DUP( dst, address, size )                                    \
+          (dst) = ft_mem_dup( memory, (address), (FT_ULong)(size), &error )
+
+#define FT_DUP( dst, address, size )                           \
+          FT_MEM_SET_ERROR( FT_MEM_DUP( dst, address, size ) )
+
+
+  /* Return >= 1 if a truncation occurs.            */
+  /* Return 0 if the source string fits the buffer. */
+  /* This is *not* the same as strlcpy().           */
+  FT_EXPORT( FT_Int )
+  ft_mem_strcpyn( char*        dst,
+                  const char*  src,
+                  FT_ULong     size );
+
+#define FT_STRCPYN( dst, src, size )                                         \
+          ft_mem_strcpyn( (char*)dst, (const char*)(src), (FT_ULong)(size) )
+
+
+FT_END_HEADER
+
+#endif /* FTMEMORY_H_ */
+
+
+/* END */
diff -Naru freetype-2.10.4-org/include/freetype/internal/ftmemory.h freetype-2.10.4/include/freetype/internal/ftmemory.h
--- freetype-2.10.4-org/include/freetype/internal/ftmemory.h	2020-08-27 14:17:20.000000000 +0800
+++ freetype-2.10.4/include/freetype/internal/ftmemory.h	2020-11-29 20:55:05.356974381 +0800
@@ -123,17 +123,17 @@
   /* The `q' variants of the functions below (`q' for `quick') don't fill */
   /* the allocated or reallocated memory with zero bytes.                 */
 
-  FT_BASE( FT_Pointer )
+  FT_EXPORT( FT_Pointer )
   ft_mem_alloc( FT_Memory  memory,
                 FT_Long    size,
                 FT_Error  *p_error );
 
-  FT_BASE( FT_Pointer )
+  FT_EXPORT( FT_Pointer )
   ft_mem_qalloc( FT_Memory  memory,
                  FT_Long    size,
                  FT_Error  *p_error );
 
-  FT_BASE( FT_Pointer )
+  FT_EXPORT( FT_Pointer )
   ft_mem_realloc( FT_Memory  memory,
                   FT_Long    item_size,
                   FT_Long    cur_count,
@@ -141,7 +141,7 @@
                   void*      block,
                   FT_Error  *p_error );
 
-  FT_BASE( FT_Pointer )
+  FT_EXPORT( FT_Pointer )
   ft_mem_qrealloc( FT_Memory  memory,
                    FT_Long    item_size,
                    FT_Long    cur_count,
@@ -149,7 +149,7 @@
                    void*      block,
                    FT_Error  *p_error );
 
-  FT_BASE( void )
+  FT_EXPORT( void )
   ft_mem_free( FT_Memory    memory,
                const void*  P );
 
@@ -354,12 +354,12 @@
           FT_MEM_SET_ERROR( FT_MEM_RENEW_ARRAY( ptr, curcnt, newcnt ) )
 
 
-  FT_BASE( FT_Pointer )
+  FT_EXPORT( FT_Pointer )
   ft_mem_strdup( FT_Memory    memory,
                  const char*  str,
                  FT_Error    *p_error );
 
-  FT_BASE( FT_Pointer )
+  FT_EXPORT( FT_Pointer )
   ft_mem_dup( FT_Memory    memory,
               const void*  address,
               FT_ULong     size,
@@ -382,7 +382,7 @@
   /* Return >= 1 if a truncation occurs.            */
   /* Return 0 if the source string fits the buffer. */
   /* This is *not* the same as strlcpy().           */
-  FT_BASE( FT_Int )
+  FT_EXPORT( FT_Int )
   ft_mem_strcpyn( char*        dst,
                   const char*  src,
                   FT_ULong     size );
diff -Naru freetype-2.10.4-org/src/base/ftutil.c freetype-2.10.4/src/base/ftutil.c
--- freetype-2.10.4-org/src/base/ftutil.c	2020-08-27 14:17:20.000000000 +0800
+++ freetype-2.10.4/src/base/ftutil.c	2020-11-29 20:53:50.652581392 +0800
@@ -45,7 +45,7 @@
   /*************************************************************************/
 
 
-  FT_BASE_DEF( FT_Pointer )
+  FT_EXPORT_DEF( FT_Pointer )
   ft_mem_alloc( FT_Memory  memory,
                 FT_Long    size,
                 FT_Error  *p_error )
@@ -61,7 +61,7 @@
   }
 
 
-  FT_BASE_DEF( FT_Pointer )
+  FT_EXPORT_DEF( FT_Pointer )
   ft_mem_qalloc( FT_Memory  memory,
                  FT_Long    size,
                  FT_Error  *p_error )
@@ -87,7 +87,7 @@
   }
 
 
-  FT_BASE_DEF( FT_Pointer )
+  FT_EXPORT_DEF( FT_Pointer )
   ft_mem_realloc( FT_Memory  memory,
                   FT_Long    item_size,
                   FT_Long    cur_count,
@@ -109,7 +109,7 @@
   }
 
 
-  FT_BASE_DEF( FT_Pointer )
+  FT_EXPORT_DEF( FT_Pointer )
   ft_mem_qrealloc( FT_Memory  memory,
                    FT_Long    item_size,
                    FT_Long    cur_count,
@@ -165,7 +165,7 @@
   }
 
 
-  FT_BASE_DEF( void )
+  FT_EXPORT_DEF( void )
   ft_mem_free( FT_Memory   memory,
                const void *P )
   {
@@ -174,7 +174,7 @@
   }
 
 
-  FT_BASE_DEF( FT_Pointer )
+  FT_EXPORT_DEF( FT_Pointer )
   ft_mem_dup( FT_Memory    memory,
               const void*  address,
               FT_ULong     size,
@@ -192,7 +192,7 @@
   }
 
 
-  FT_BASE_DEF( FT_Pointer )
+  FT_EXPORT_DEF( FT_Pointer )
   ft_mem_strdup( FT_Memory    memory,
                  const char*  str,
                  FT_Error    *p_error )
@@ -205,7 +205,7 @@
   }
 
 
-  FT_BASE_DEF( FT_Int )
+  FT_EXPORT_DEF( FT_Int )
   ft_mem_strcpyn( char*        dst,
                   const char*  src,
                   FT_ULong     size )
@@ -239,7 +239,7 @@
 
   /* documentation is in ftlist.h */
 
-  FT_EXPORT_DEF( FT_ListNode )
+  FT_EXPORT_DEF( FT_ListNode )
   FT_List_Find( FT_List  list,
                 void*    data )
   {
diff -Naru freetype-2.10.4-org/src/bdf/bdfdrivr.c freetype-2.10.4/src/bdf/bdfdrivr.c
--- freetype-2.10.4-org/src/bdf/bdfdrivr.c	2020-08-27 14:17:20.000000000 +0800
+++ freetype-2.10.4/src/bdf/bdfdrivr.c	2020-11-29 20:53:50.652581392 +0800
@@ -40,20 +40,20 @@
 #include "bdferror.h"
 
 
-  /**************************************************************************
-   *
-   * The macro FT_COMPONENT is used in trace mode.  It is an implicit
-   * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log
-   * messages during execution.
-   */
+  /*************************************************************************/
+  /*                                                                       */
+  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
+  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
+  /* messages during execution.                                            */
+  /*                                                                       */
 #undef  FT_COMPONENT
-#define FT_COMPONENT  bdfdriver
+#define FT_COMPONENT  trace_bdfdriver
 
 
   typedef struct  BDF_CMapRec_
   {
     FT_CMapRec        cmap;
-    FT_ULong          num_encodings; /* ftobjs.h: FT_CMap->clazz->size */
+    FT_UInt           num_encodings;
     BDF_encoding_el*  encodings;
 
   } BDF_CMapRec, *BDF_CMap;
@@ -71,7 +71,7 @@
     cmap->num_encodings = face->bdffont->glyphs_used;
     cmap->encodings     = face->en_table;
 
-    return FT_Err_Ok;
+    return BDF_Err_Ok;
   }
 
 
@@ -92,22 +92,19 @@
   {
     BDF_CMap          cmap      = (BDF_CMap)bdfcmap;
     BDF_encoding_el*  encodings = cmap->encodings;
-    FT_ULong          min, max, mid; /* num_encodings */
-    FT_UShort         result    = 0; /* encodings->glyph */
+    FT_UInt           min, max, mid;
+    FT_UInt           result    = 0;
 
 
     min = 0;
     max = cmap->num_encodings;
-    mid = ( min + max ) >> 1;
 
     while ( min < max )
     {
-      FT_ULong  code;
-
+      FT_UInt32  code;
 
-      if ( mid >= max || mid < min )
-        mid = ( min + max ) >> 1;
 
+      mid  = ( min + max ) >> 1;
       code = encodings[mid].enc;
 
       if ( charcode == code )
@@ -122,9 +119,6 @@
         max = mid;
       else
         min = mid + 1;
-
-      /* prediction in a continuous block */
-      mid += charcode - code;
     }
 
     return result;
@@ -137,23 +131,20 @@
   {
     BDF_CMap          cmap      = (BDF_CMap)bdfcmap;
     BDF_encoding_el*  encodings = cmap->encodings;
-    FT_ULong          min, max, mid; /* num_encodings */
-    FT_UShort         result   = 0;  /* encodings->glyph */
-    FT_ULong          charcode = *acharcode + 1;
+    FT_UInt           min, max, mid;
+    FT_UInt32         charcode = *acharcode + 1;
+    FT_UInt           result   = 0;
 
 
     min = 0;
     max = cmap->num_encodings;
-    mid = ( min + max ) >> 1;
 
     while ( min < max )
     {
-      FT_ULong  code; /* same as BDF_encoding_el.enc */
-
+      FT_UInt32  code;
 
-      if ( mid >= max || mid < min )
-        mid = ( min + max ) >> 1;
 
+      mid  = ( min + max ) >> 1;
       code = encodings[mid].enc;
 
       if ( charcode == code )
@@ -168,9 +159,6 @@
         max = mid;
       else
         min = mid + 1;
-
-      /* prediction in a continuous block */
-      mid += charcode - code;
     }
 
     charcode = 0;
@@ -181,137 +169,128 @@
     }
 
   Exit:
-    if ( charcode > 0xFFFFFFFFUL )
-    {
-      FT_TRACE1(( "bdf_cmap_char_next: charcode 0x%lx > 32bit API",
-                  charcode ));
-      *acharcode = 0;
-      /* XXX: result should be changed to indicate an overflow error */
-    }
-    else
-      *acharcode = (FT_UInt32)charcode;
+    *acharcode = charcode;
     return result;
   }
 
 
-  static
+  FT_CALLBACK_TABLE_DEF
   const FT_CMap_ClassRec  bdf_cmap_class =
   {
     sizeof ( BDF_CMapRec ),
     bdf_cmap_init,
     bdf_cmap_done,
     bdf_cmap_char_index,
-    bdf_cmap_char_next,
-
-    NULL, NULL, NULL, NULL, NULL
+    bdf_cmap_char_next
   };
 
 
   static FT_Error
   bdf_interpret_style( BDF_Face  bdf )
   {
-    FT_Error         error  = FT_Err_Ok;
+    FT_Error         error  = BDF_Err_Ok;
     FT_Face          face   = FT_FACE( bdf );
     FT_Memory        memory = face->memory;
     bdf_font_t*      font   = bdf->bdffont;
     bdf_property_t*  prop;
 
-    const char*   strings[4] = { NULL, NULL, NULL, NULL };
-    size_t        lengths[4], nn, len;
+    char  *istr = NULL, *bstr = NULL;
+    char  *sstr = NULL, *astr = NULL;
+
+    int  parts = 0, len = 0;
 
 
     face->style_flags = 0;
 
-    prop = bdf_get_font_property( font, "SLANT" );
+    prop = bdf_get_font_property( font, (char *)"SLANT" );
     if ( prop && prop->format == BDF_ATOM                             &&
          prop->value.atom                                             &&
          ( *(prop->value.atom) == 'O' || *(prop->value.atom) == 'o' ||
            *(prop->value.atom) == 'I' || *(prop->value.atom) == 'i' ) )
     {
       face->style_flags |= FT_STYLE_FLAG_ITALIC;
-      strings[2] = ( *(prop->value.atom) == 'O' || *(prop->value.atom) == 'o' )
-                   ? "Oblique"
-                   : "Italic";
+      istr = ( *(prop->value.atom) == 'O' || *(prop->value.atom) == 'o' )
+               ? (char *)"Oblique"
+               : (char *)"Italic";
+      len += ft_strlen( istr );
+      parts++;
     }
 
-    prop = bdf_get_font_property( font, "WEIGHT_NAME" );
+    prop = bdf_get_font_property( font, (char *)"WEIGHT_NAME" );
     if ( prop && prop->format == BDF_ATOM                             &&
          prop->value.atom                                             &&
          ( *(prop->value.atom) == 'B' || *(prop->value.atom) == 'b' ) )
     {
       face->style_flags |= FT_STYLE_FLAG_BOLD;
-      strings[1] = "Bold";
+      bstr = (char *)"Bold";
+      len += ft_strlen( bstr );
+      parts++;
     }
 
-    prop = bdf_get_font_property( font, "SETWIDTH_NAME" );
+    prop = bdf_get_font_property( font, (char *)"SETWIDTH_NAME" );
     if ( prop && prop->format == BDF_ATOM                              &&
          prop->value.atom && *(prop->value.atom)                       &&
          !( *(prop->value.atom) == 'N' || *(prop->value.atom) == 'n' ) )
-      strings[3] = (const char *)(prop->value.atom);
+    {
+      sstr = (char *)(prop->value.atom);
+      len += ft_strlen( sstr );
+      parts++;
+    }
 
-    prop = bdf_get_font_property( font, "ADD_STYLE_NAME" );
+    prop = bdf_get_font_property( font, (char *)"ADD_STYLE_NAME" );
     if ( prop && prop->format == BDF_ATOM                              &&
          prop->value.atom && *(prop->value.atom)                       &&
          !( *(prop->value.atom) == 'N' || *(prop->value.atom) == 'n' ) )
-      strings[0] = (const char *)(prop->value.atom);
-
-    for ( len = 0, nn = 0; nn < 4; nn++ )
     {
-      lengths[nn] = 0;
-      if ( strings[nn] )
-      {
-        lengths[nn] = ft_strlen( strings[nn] );
-        len        += lengths[nn] + 1;
-      }
-    }
-
-    if ( len == 0 )
-    {
-      strings[0] = "Regular";
-      lengths[0] = ft_strlen( strings[0] );
-      len        = lengths[0] + 1;
+      astr = (char *)(prop->value.atom);
+      len += ft_strlen( astr );
+      parts++;
     }
 
+    if ( !parts || !len )
+      face->style_name = (char *)"Regular";
+    else
     {
-      char*  s;
+      char          *style, *s;
+      unsigned int  i;
 
 
-      if ( FT_ALLOC( face->style_name, len ) )
+      if ( FT_ALLOC( style, len + parts ) )
         return error;
 
-      s = face->style_name;
+      s = style;
 
-      for ( nn = 0; nn < 4; nn++ )
+      if ( astr )
       {
-        const char*  src = strings[nn];
-
-
-        len = lengths[nn];
-
-        if ( !src )
-          continue;
-
-        /* separate elements with a space */
-        if ( s != face->style_name )
-          *s++ = ' ';
-
-        ft_memcpy( s, src, len );
-
-        /* need to convert spaces to dashes for */
-        /* add_style_name and setwidth_name     */
-        if ( nn == 0 || nn == 3 )
-        {
-          size_t  mm;
-
-
-          for ( mm = 0; mm < len; mm++ )
-            if ( s[mm] == ' ' )
-              s[mm] = '-';
-        }
-
-        s += len;
+        ft_strcpy( s, astr );
+        for ( i = 0; i < ft_strlen( astr ); i++, s++ )
+          if ( *s == ' ' )
+            *s = '-';                     /* replace spaces with dashes */
+        *(s++) = ' ';
       }
-      *s = 0;
+      if ( bstr )
+      {
+        ft_strcpy( s, bstr );
+        s += ft_strlen( bstr );
+        *(s++) = ' ';
+      }
+      if ( istr )
+      {
+        ft_strcpy( s, istr );
+        s += ft_strlen( istr );
+        *(s++) = ' ';
+      }
+      if ( sstr )
+      {
+        ft_strcpy( s, sstr );
+        for ( i = 0; i < ft_strlen( sstr ); i++, s++ )
+          if ( *s == ' ' )
+            *s = '-';                     /* replace spaces with dashes */
+        *(s++) = ' ';
+      }
+      *(--s) = '\0';        /* overwrite last ' ', terminate the string */
+
+      face->style_name = style;                     /* allocated string */
     }
 
     return error;
@@ -321,14 +300,9 @@
   FT_CALLBACK_DEF( void )
   BDF_Face_Done( FT_Face  bdfface )         /* BDF_Face */
   {
-    BDF_Face   face = (BDF_Face)bdfface;
-    FT_Memory  memory;
-
-
-    if ( !face )
-      return;
+    BDF_Face   face   = (BDF_Face)bdfface;
+    FT_Memory  memory = FT_FACE_MEMORY( face );
 
-    memory = FT_FACE_MEMORY( face );
 
     bdf_free_font( face->bdffont );
 
@@ -337,11 +311,12 @@
     FT_FREE( face->charset_encoding );
     FT_FREE( face->charset_registry );
     FT_FREE( bdfface->family_name );
-    FT_FREE( bdfface->style_name );
 
     FT_FREE( bdfface->available_sizes );
 
     FT_FREE( face->bdffont );
+
+    FT_TRACE4(( "BDF_Face_Done: done face\n" ));
   }
 
 
@@ -352,7 +327,7 @@
                  FT_Int         num_params,
                  FT_Parameter*  params )
   {
-    FT_Error       error  = FT_Err_Ok;
+    FT_Error       error  = BDF_Err_Ok;
     BDF_Face       face   = (BDF_Face)bdfface;
     FT_Memory      memory = FT_FACE_MEMORY( face );
 
@@ -361,10 +336,9 @@
 
     FT_UNUSED( num_params );
     FT_UNUSED( params );
+    FT_UNUSED( face_index );
 
 
-    FT_TRACE2(( "BDF driver\n" ));
-
     if ( FT_STREAM_SEEK( 0 ) )
       goto Exit;
 
@@ -374,9 +348,9 @@
     options.font_spacing    = BDF_PROPORTIONAL;
 
     error = bdf_load_font( stream, memory, &options, &font );
-    if ( FT_ERR_EQ( error, Missing_Startfont_Field ) )
+    if ( error == BDF_Err_Missing_Startfont_Field )
     {
-      FT_TRACE2(( "  not a BDF file\n" ));
+      FT_TRACE2(( "[not a valid BDF file]\n" ));
       goto Fail;
     }
     else if ( error )
@@ -384,36 +358,22 @@
 
     /* we have a bdf font: let's construct the face object */
     face->bdffont = font;
-
-    /* BDF cannot have multiple faces in a single font file.
-     * XXX: non-zero face_index is already invalid argument, but
-     *      Type1, Type42 driver has a convention to return
-     *      an invalid argument error when the font could be
-     *      opened by the specified driver.
-     */
-    if ( face_index > 0 && ( face_index & 0xFFFF ) > 0 )
-    {
-      FT_ERROR(( "BDF_Face_Init: invalid face index\n" ));
-      BDF_Face_Done( bdfface );
-      return FT_THROW( Invalid_Argument );
-    }
-
     {
       bdf_property_t*  prop = NULL;
 
 
-      FT_TRACE4(( "  number of glyphs: allocated %ld (used %ld)\n",
+      FT_TRACE4(( "number of glyphs: %d (%d)\n",
                   font->glyphs_size,
                   font->glyphs_used ));
-      FT_TRACE4(( "  number of unencoded glyphs: allocated %ld (used %ld)\n",
+      FT_TRACE4(( "number of unencoded glyphs: %d (%d)\n",
                   font->unencoded_size,
                   font->unencoded_used ));
 
       bdfface->num_faces  = 1;
       bdfface->face_index = 0;
-
-      bdfface->face_flags |= FT_FACE_FLAG_FIXED_SIZES |
-                             FT_FACE_FLAG_HORIZONTAL;
+      bdfface->face_flags = FT_FACE_FLAG_FIXED_SIZES |
+                            FT_FACE_FLAG_HORIZONTAL  |
+                            FT_FACE_FLAG_FAST_GLYPHS;
 
       prop = bdf_get_font_property( font, "SPACING" );
       if ( prop && prop->format == BDF_ATOM                             &&
@@ -428,18 +388,27 @@
       prop = bdf_get_font_property( font, "FAMILY_NAME" );
       if ( prop && prop->value.atom )
       {
-        if ( FT_STRDUP( bdfface->family_name, prop->value.atom ) )
+        int  l = ft_strlen( prop->value.atom ) + 1;
+
+
+        if ( FT_NEW_ARRAY( bdfface->family_name, l ) )
           goto Exit;
+        ft_strcpy( bdfface->family_name, prop->value.atom );
       }
       else
-        bdfface->family_name = NULL;
+        bdfface->family_name = 0;
 
-      if ( FT_SET_ERROR( bdf_interpret_style( face ) ) )
+      if ( ( error = bdf_interpret_style( face ) ) != 0 )
         goto Exit;
 
       /* the number of glyphs (with one slot for the undefined glyph */
       /* at position 0 and all unencoded glyphs)                     */
-      bdfface->num_glyphs = (FT_Long)( font->glyphs_size + 1 );
+      bdfface->num_glyphs = font->glyphs_size + 1;
+
+      bdfface->ascender          = (FT_Short) font->font_ascent;
+      bdfface->descender         = (FT_Short) -font->font_descent;
+      bdfface->height            = (FT_Short) ( font->font_ascent + font->font_descent );
+      bdfface->max_advance_width = (FT_Short) font->bbx.width;
 
       bdfface->num_fixed_sizes = 1;
       if ( FT_NEW_ARRAY( bdfface->available_sizes, 1 ) )
@@ -448,156 +417,44 @@
       {
         FT_Bitmap_Size*  bsize = bdfface->available_sizes;
         FT_Short         resolution_x = 0, resolution_y = 0;
-        long             value;
 
 
-        FT_ZERO( bsize );
-
-        /* sanity checks */
-        if ( font->font_ascent > 0x7FFF || font->font_ascent < -0x7FFF )
-        {
-          font->font_ascent = font->font_ascent < 0 ? -0x7FFF : 0x7FFF;
-          FT_TRACE0(( "BDF_Face_Init: clamping font ascent to value %ld\n",
-                      font->font_ascent ));
-        }
-        if ( font->font_descent > 0x7FFF || font->font_descent < -0x7FFF )
-        {
-          font->font_descent = font->font_descent < 0 ? -0x7FFF : 0x7FFF;
-          FT_TRACE0(( "BDF_Face_Init: clamping font descent to value %ld\n",
-                      font->font_descent ));
-        }
+        FT_MEM_ZERO( bsize, sizeof ( FT_Bitmap_Size ) );
 
         bsize->height = (FT_Short)( font->font_ascent + font->font_descent );
 
         prop = bdf_get_font_property( font, "AVERAGE_WIDTH" );
         if ( prop )
-        {
-#ifdef FT_DEBUG_LEVEL_TRACE
-          if ( prop->value.l < 0 )
-            FT_TRACE0(( "BDF_Face_Init: negative average width\n" ));
-#endif
-          if ( prop->value.l >    0x7FFFL * 10 - 5   ||
-               prop->value.l < -( 0x7FFFL * 10 - 5 ) )
-          {
-            bsize->width = 0x7FFF;
-            FT_TRACE0(( "BDF_Face_Init: clamping average width to value %d\n",
-                        bsize->width ));
-          }
-          else
-            bsize->width = FT_ABS( (FT_Short)( ( prop->value.l + 5 ) / 10 ) );
-        }
+          bsize->width = (FT_Short)( ( prop->value.int32 + 5 ) / 10 );
         else
-        {
-          /* this is a heuristical value */
-          bsize->width = (FT_Short)FT_MulDiv( bsize->height, 2, 3 );
-        }
+          bsize->width = (FT_Short)( bsize->height * 2/3 );
 
         prop = bdf_get_font_property( font, "POINT_SIZE" );
         if ( prop )
-        {
-#ifdef FT_DEBUG_LEVEL_TRACE
-          if ( prop->value.l < 0 )
-            FT_TRACE0(( "BDF_Face_Init: negative point size\n" ));
-#endif
           /* convert from 722.7 decipoints to 72 points per inch */
-          if ( prop->value.l >  0x504C2L || /* 0x7FFF * 72270/7200 */
-               prop->value.l < -0x504C2L )
-          {
-            bsize->size = 0x7FFF;
-            FT_TRACE0(( "BDF_Face_Init: clamping point size to value %ld\n",
-                        bsize->size ));
-          }
-          else
-            bsize->size = FT_MulDiv( FT_ABS( prop->value.l ),
-                                     64 * 7200,
-                                     72270L );
-        }
-        else if ( font->point_size )
-        {
-          if ( font->point_size > 0x7FFF )
-          {
-            bsize->size = 0x7FFF;
-            FT_TRACE0(( "BDF_Face_Init: clamping point size to value %ld\n",
-                        bsize->size ));
-          }
-          else
-            bsize->size = (FT_Pos)font->point_size << 6;
-        }
-        else
-        {
-          /* this is a heuristical value */
-          bsize->size = bsize->width * 64;
-        }
+          bsize->size =
+            (FT_Pos)( ( prop->value.int32 * 64 * 7200 + 36135L ) / 72270L );
 
         prop = bdf_get_font_property( font, "PIXEL_SIZE" );
         if ( prop )
-        {
-#ifdef FT_DEBUG_LEVEL_TRACE
-          if ( prop->value.l < 0 )
-            FT_TRACE0(( "BDF_Face_Init: negative pixel size\n" ));
-#endif
-          if ( prop->value.l > 0x7FFF || prop->value.l < -0x7FFF )
-          {
-            bsize->y_ppem = 0x7FFF << 6;
-            FT_TRACE0(( "BDF_Face_Init: clamping pixel size to value %ld\n",
-                        bsize->y_ppem ));
-          }
-          else
-            bsize->y_ppem = FT_ABS( (FT_Short)prop->value.l ) << 6;
-        }
+          bsize->y_ppem = (FT_Short)prop->value.int32 << 6;
 
         prop = bdf_get_font_property( font, "RESOLUTION_X" );
         if ( prop )
-          value = prop->value.l;
-        else
-          value = (long)font->resolution_x;
-        if ( value )
-        {
-#ifdef FT_DEBUG_LEVEL_TRACE
-          if ( value < 0 )
-            FT_TRACE0(( "BDF_Face_Init: negative X resolution\n" ));
-#endif
-          if ( value > 0x7FFF || value < -0x7FFF )
-          {
-            resolution_x = 0x7FFF;
-            FT_TRACE0(( "BDF_Face_Init: clamping X resolution to value %d\n",
-                        resolution_x ));
-          }
-          else
-            resolution_x = FT_ABS( (FT_Short)value );
-        }
+          resolution_x = (FT_Short)prop->value.int32;
 
         prop = bdf_get_font_property( font, "RESOLUTION_Y" );
         if ( prop )
-          value = prop->value.l;
-        else
-          value = (long)font->resolution_y;
-        if ( value )
-        {
-#ifdef FT_DEBUG_LEVEL_TRACE
-          if ( value < 0 )
-            FT_TRACE0(( "BDF_Face_Init: negative Y resolution\n" ));
-#endif
-          if ( value > 0x7FFF || value < -0x7FFF )
-          {
-            resolution_y = 0x7FFF;
-            FT_TRACE0(( "BDF_Face_Init: clamping Y resolution to value %d\n",
-                        resolution_y ));
-          }
-          else
-            resolution_y = FT_ABS( (FT_Short)value );
-        }
+          resolution_y = (FT_Short)prop->value.int32;
 
         if ( bsize->y_ppem == 0 )
         {
           bsize->y_ppem = bsize->size;
           if ( resolution_y )
-            bsize->y_ppem = FT_MulDiv( bsize->y_ppem, resolution_y, 72 );
+            bsize->y_ppem = bsize->y_ppem * resolution_y / 72;
         }
         if ( resolution_x && resolution_y )
-          bsize->x_ppem = FT_MulDiv( bsize->y_ppem,
-                                     resolution_x,
-                                     resolution_y );
+          bsize->x_ppem = bsize->y_ppem * resolution_x / resolution_y;
         else
           bsize->x_ppem = bsize->y_ppem;
       }
@@ -615,23 +472,17 @@
         for ( n = 0; n < font->glyphs_size; n++ )
         {
           (face->en_table[n]).enc = cur[n].encoding;
-          FT_TRACE4(( "  idx %ld, val 0x%lX\n", n, cur[n].encoding ));
-          (face->en_table[n]).glyph = (FT_UShort)n;
-
+          FT_TRACE4(( "idx %d, val 0x%lX\n", n, cur[n].encoding ));
+          (face->en_table[n]).glyph = (FT_Short)n;
+  
           if ( cur[n].encoding == font->default_char )
-          {
-            if ( n < FT_UINT_MAX )
-              face->default_glyph = (FT_UInt)n;
-            else
-              FT_TRACE1(( "BDF_Face_Init:"
-                          " idx %ld is too large for this system\n", n ));
-          }
+            face->default_glyph = n;
         }
       }
 
       /* charmaps */
       {
-        bdf_property_t  *charset_registry, *charset_encoding;
+        bdf_property_t  *charset_registry = 0, *charset_encoding = 0;
         FT_Bool          unicode_charmap  = 0;
 
 
@@ -649,14 +500,18 @@
             const char*  s;
 
 
-            if ( FT_STRDUP( face->charset_encoding,
-                            charset_encoding->value.atom ) ||
-                 FT_STRDUP( face->charset_registry,
-                            charset_registry->value.atom ) )
+            if ( FT_NEW_ARRAY( face->charset_encoding,
+                               ft_strlen( charset_encoding->value.atom ) + 1 ) )
+              goto Exit;
+            if ( FT_NEW_ARRAY( face->charset_registry,
+                               ft_strlen( charset_registry->value.atom ) + 1 ) )
               goto Exit;
 
-            /* Uh, oh, compare first letters manually to avoid dependency */
-            /* on locales.                                                */
+            ft_strcpy( face->charset_registry, charset_registry->value.atom );
+            ft_strcpy( face->charset_encoding, charset_encoding->value.atom );
+
+            /* Uh, oh, compare first letters manually to avoid dependency
+               on locales. */
             s = face->charset_registry;
             if ( ( s[0] == 'i' || s[0] == 'I' ) &&
                  ( s[1] == 's' || s[1] == 'S' ) &&
@@ -666,11 +521,7 @@
               if ( !ft_strcmp( s, "10646" )                      ||
                    ( !ft_strcmp( s, "8859" ) &&
                      !ft_strcmp( face->charset_encoding, "1" ) ) )
-                unicode_charmap = 1;
-              /* another name for ASCII */
-              else if ( !ft_strcmp( s, "646.1991" )                 &&
-                        !ft_strcmp( face->charset_encoding, "IRV" ) )
-                unicode_charmap = 1;
+              unicode_charmap = 1;
             }
 
             {
@@ -679,18 +530,23 @@
 
               charmap.face        = FT_FACE( face );
               charmap.encoding    = FT_ENCODING_NONE;
-              /* initial platform/encoding should indicate unset status? */
-              charmap.platform_id = TT_PLATFORM_APPLE_UNICODE;
-              charmap.encoding_id = TT_APPLE_ID_DEFAULT;
+              charmap.platform_id = 0;
+              charmap.encoding_id = 0;
 
               if ( unicode_charmap )
               {
                 charmap.encoding    = FT_ENCODING_UNICODE;
-                charmap.platform_id = TT_PLATFORM_MICROSOFT;
-                charmap.encoding_id = TT_MS_ID_UNICODE_CS;
+                charmap.platform_id = 3;
+                charmap.encoding_id = 1;
               }
 
               error = FT_CMap_New( &bdf_cmap_class, NULL, &charmap, NULL );
+
+#if 0
+              /* Select default charmap */
+              if ( bdfface->num_charmaps )
+                bdfface->charmap = bdfface->charmaps[0];
+#endif
             }
 
             goto Exit;
@@ -705,8 +561,8 @@
 
           charmap.face        = FT_FACE( face );
           charmap.encoding    = FT_ENCODING_ADOBE_STANDARD;
-          charmap.platform_id = TT_PLATFORM_ADOBE;
-          charmap.encoding_id = TT_ADOBE_ID_STANDARD;
+          charmap.platform_id = 7;
+          charmap.encoding_id = 0;
 
           error = FT_CMap_New( &bdf_cmap_class, NULL, &charmap, NULL );
 
@@ -789,25 +645,18 @@
                   FT_UInt       glyph_index,
                   FT_Int32      load_flags )
   {
-    BDF_Face     bdf    = (BDF_Face)FT_SIZE_FACE( size );
-    FT_Face      face   = FT_FACE( bdf );
-    FT_Error     error  = FT_Err_Ok;
+    BDF_Face     face   = (BDF_Face)FT_SIZE_FACE( size );
+    FT_Error     error  = BDF_Err_Ok;
     FT_Bitmap*   bitmap = &slot->bitmap;
     bdf_glyph_t  glyph;
-    int          bpp    = bdf->bdffont->bpp;
+    int          bpp    = face->bdffont->bpp;
 
     FT_UNUSED( load_flags );
 
 
     if ( !face )
     {
-      error = FT_THROW( Invalid_Face_Handle );
-      goto Exit;
-    }
-
-    if ( glyph_index >= (FT_UInt)face->num_glyphs )
-    {
-      error = FT_THROW( Invalid_Argument );
+      error = BDF_Err_Invalid_Argument;
       goto Exit;
     }
 
@@ -815,19 +664,16 @@
 
     /* index 0 is the undefined glyph */
     if ( glyph_index == 0 )
-      glyph_index = bdf->default_glyph;
+      glyph_index = face->default_glyph;
     else
       glyph_index--;
 
     /* slot, bitmap => freetype, glyph => bdflib */
-    glyph = bdf->bdffont->glyphs[glyph_index];
+    glyph = face->bdffont->glyphs[glyph_index];
 
     bitmap->rows  = glyph.bbx.height;
     bitmap->width = glyph.bbx.width;
-    if ( glyph.bpr > FT_INT_MAX )
-      FT_TRACE1(( "BDF_Glyph_Load: too large pitch %ld is truncated\n",
-                   glyph.bpr ));
-    bitmap->pitch = (int)glyph.bpr; /* same as FT_Bitmap.pitch */
+    bitmap->pitch = glyph.bpr;
 
     /* note: we don't allocate a new array to hold the bitmap; */
     /*       we can simply point to it                         */
@@ -860,12 +706,12 @@
     slot->metrics.width        = (FT_Pos)( bitmap->width * 64 );
     slot->metrics.height       = (FT_Pos)( bitmap->rows * 64 );
 
-    /*
-     * XXX DWIDTH1 and VVECTOR should be parsed and
+    slot->linearHoriAdvance = (FT_Fixed)glyph.dwidth << 16;
+     /** XXX DWIDTH1 and VVECTOR should be parsed and
      * used here, provided such fonts do exist.
      */
     ft_synthesize_vertical_metrics( &slot->metrics,
-                                    bdf->bdffont->bbx.height * 64 );
+                                    face->bdffont->bbx.height * 64 );
 
   Exit:
     return error;
@@ -874,7 +720,7 @@
 
  /*
   *
-  * BDF SERVICE
+  *  BDF SERVICE
   *
   */
 
@@ -899,25 +745,23 @@
         break;
 
       case BDF_INTEGER:
-        if ( prop->value.l > 0x7FFFFFFFL || prop->value.l < ( -1 - 0x7FFFFFFFL ) )
+        if ( prop->value.int32 > 0x7FFFFFFFL || prop->value.int32 < ( -1 - 0x7FFFFFFFL ) )
         {
           FT_TRACE1(( "bdf_get_bdf_property:"
-                      " too large integer 0x%lx is truncated\n",
-                      prop->value.l ));
+                      " too large integer 0x%x is truncated\n" ));
         }
         aproperty->type      = BDF_PROPERTY_TYPE_INTEGER;
-        aproperty->u.integer = (FT_Int32)prop->value.l;
+        aproperty->u.integer = (FT_Int32)prop->value.int32;
         break;
 
       case BDF_CARDINAL:
-        if ( prop->value.ul > 0xFFFFFFFFUL )
+        if ( prop->value.card32 > 0xFFFFFFFFUL )
         {
           FT_TRACE1(( "bdf_get_bdf_property:"
-                      " too large cardinal 0x%lx is truncated\n",
-                      prop->value.ul ));
+                      " too large cardinal 0x%x is truncated\n" ));
         }
         aproperty->type       = BDF_PROPERTY_TYPE_CARDINAL;
-        aproperty->u.cardinal = (FT_UInt32)prop->value.ul;
+        aproperty->u.cardinal = (FT_UInt32)prop->value.card32;
         break;
 
       default:
@@ -952,7 +796,7 @@
 
  /*
   *
-  * SERVICES LIST
+  *  SERVICES LIST
   *
   */
 
diff -Naru freetype-2.10.4-org/src/bdf/bdf.h freetype-2.10.4/src/bdf/bdf.h
--- freetype-2.10.4-org/src/bdf/bdf.h	2020-08-27 14:17:20.000000000 +0800
+++ freetype-2.10.4/src/bdf/bdf.h	2020-11-29 20:53:50.652581392 +0800
@@ -108,14 +108,14 @@
   /* There are a set of defaults and each font has their own.   */
   typedef struct  bdf_property_t_
   {
-    const char*  name;         /* Name of the property.   */
-    int          format;       /* Format of the property. */
-    int          builtin;      /* A builtin property.     */
+    char*  name;         /* Name of the property.   */
+    int    format;       /* Format of the property. */
+    int    builtin;      /* A builtin property.     */
     union
     {
       char*          atom;
-      long           l;
-      unsigned long  ul;
+      long           int32;
+      unsigned long  card32;
 
     } value;             /* Value of the property.  */
 
@@ -146,7 +146,7 @@
   typedef struct  bdf_glyph_t_
   {
     char*           name;        /* Glyph name.                          */
-    unsigned long   encoding;    /* Glyph encoding.                      */
+    long            encoding;    /* Glyph encoding.                      */
     unsigned short  swidth;      /* Scalable width.                      */
     unsigned short  dwidth;      /* Device width.                        */
     bdf_bbx_t       bbx;         /* Glyph bounding box.                  */
@@ -157,6 +157,38 @@
   } bdf_glyph_t;
 
 
+  typedef struct  _hashnode_
+  {
+    const char*  key;
+    void*        data;
+  
+  } _hashnode, *hashnode;
+
+
+  typedef struct  hashtable_
+  {
+    int        limit;
+    int        size;
+    int        used;
+    hashnode*  table;
+
+  } hashtable;
+
+
+  typedef struct  bdf_glyphlist_t_
+  {
+    unsigned short  pad;          /* Pad to 4-byte boundary.              */
+    unsigned short  bpp;          /* Bits per pixel.                      */
+    long            start;        /* Beginning encoding value of glyphs.  */
+    long            end;          /* Ending encoding value of glyphs.     */
+    bdf_glyph_t*    glyphs;       /* Glyphs themselves.                   */
+    unsigned long   glyphs_size;  /* Glyph structures allocated.          */
+    unsigned long   glyphs_used;  /* Glyph structures used.               */
+    bdf_bbx_t       bbx;          /* Overall bounding box of glyphs.      */
+
+  } bdf_glyphlist_t;
+
+
   typedef struct  bdf_font_t_
   {
     char*            name;           /* Name of the font.                   */
@@ -170,7 +202,7 @@
 
     unsigned short   monowidth;      /* Logical width for monowidth font.   */
 
-    unsigned long    default_char;   /* Encoding of the default glyph.      */
+    long             default_char;   /* Encoding of the default glyph.      */
 
     long             font_ascent;    /* Font ascent.                        */
     long             font_descent;   /* Font descent.                       */
@@ -190,15 +222,23 @@
     char*            comments;       /* Font comments.                      */
     unsigned long    comments_len;   /* Length of comment string.           */
 
+    bdf_glyphlist_t  overflow;       /* Storage used for glyph insertion.   */
+
     void*            internal;       /* Internal data for the font.         */
 
+    /* The size of the next two arrays must be in sync with the */
+    /* size of the `have' array in the `bdf_parse_t' structure. */
+    unsigned long    nmod[34816];    /* Bitmap indicating modified glyphs.  */
+    unsigned long    umod[34816];    /* Bitmap indicating modified          */
+                                     /* unencoded glyphs.                   */
+    unsigned short   modified;       /* Boolean indicating font modified.   */
     unsigned short   bpp;            /* Bits per pixel.                     */
 
     FT_Memory        memory;
 
     bdf_property_t*  user_props;
     unsigned long    nuser_props;
-    FT_HashRec       proptbl;
+    hashtable        proptbl;
 
   } bdf_font_t;
 
diff -Naru freetype-2.10.4-org/src/bdf/bdflib.c freetype-2.10.4/src/bdf/bdflib.c
--- freetype-2.10.4-org/src/bdf/bdflib.c	2020-08-31 15:26:12.000000000 +0800
+++ freetype-2.10.4/src/bdf/bdflib.c	2020-11-29 20:53:50.652581392 +0800
@@ -41,21 +41,20 @@
 #include "bdferror.h"
 
 
-  /**************************************************************************
-   *
-   * The macro FT_COMPONENT is used in trace mode.  It is an implicit
-   * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log
-   * messages during execution.
-   */
+  /*************************************************************************/
+  /*                                                                       */
+  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
+  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
+  /* messages during execution.                                            */
+  /*                                                                       */
 #undef  FT_COMPONENT
-#define FT_COMPONENT  bdflib
+#define FT_COMPONENT  trace_bdflib
 
-
-  /**************************************************************************
-   *
-   * Default BDF font options.
-   *
-   */
+  /*************************************************************************/
+  /*                                                                       */
+  /* Default BDF font options.                                             */
+  /*                                                                       */
+  /*************************************************************************/
 
 
   static const bdf_options_t  _bdf_opts =
@@ -67,100 +66,100 @@
   };
 
 
-  /**************************************************************************
-   *
-   * Builtin BDF font properties.
-   *
-   */
+  /*************************************************************************/
+  /*                                                                       */
+  /* Builtin BDF font properties.                                          */
+  /*                                                                       */
+  /*************************************************************************/
 
   /* List of most properties that might appear in a font.  Doesn't include */
   /* the RAW_* and AXIS_* properties in X11R6 polymorphic fonts.           */
 
   static const bdf_property_t  _bdf_properties[] =
   {
-    { "ADD_STYLE_NAME",          BDF_ATOM,     1, { 0 } },
-    { "AVERAGE_WIDTH",           BDF_INTEGER,  1, { 0 } },
-    { "AVG_CAPITAL_WIDTH",       BDF_INTEGER,  1, { 0 } },
-    { "AVG_LOWERCASE_WIDTH",     BDF_INTEGER,  1, { 0 } },
-    { "CAP_HEIGHT",              BDF_INTEGER,  1, { 0 } },
-    { "CHARSET_COLLECTIONS",     BDF_ATOM,     1, { 0 } },
-    { "CHARSET_ENCODING",        BDF_ATOM,     1, { 0 } },
-    { "CHARSET_REGISTRY",        BDF_ATOM,     1, { 0 } },
-    { "COMMENT",                 BDF_ATOM,     1, { 0 } },
-    { "COPYRIGHT",               BDF_ATOM,     1, { 0 } },
-    { "DEFAULT_CHAR",            BDF_CARDINAL, 1, { 0 } },
-    { "DESTINATION",             BDF_CARDINAL, 1, { 0 } },
-    { "DEVICE_FONT_NAME",        BDF_ATOM,     1, { 0 } },
-    { "END_SPACE",               BDF_INTEGER,  1, { 0 } },
-    { "FACE_NAME",               BDF_ATOM,     1, { 0 } },
-    { "FAMILY_NAME",             BDF_ATOM,     1, { 0 } },
-    { "FIGURE_WIDTH",            BDF_INTEGER,  1, { 0 } },
-    { "FONT",                    BDF_ATOM,     1, { 0 } },
-    { "FONTNAME_REGISTRY",       BDF_ATOM,     1, { 0 } },
-    { "FONT_ASCENT",             BDF_INTEGER,  1, { 0 } },
-    { "FONT_DESCENT",            BDF_INTEGER,  1, { 0 } },
-    { "FOUNDRY",                 BDF_ATOM,     1, { 0 } },
-    { "FULL_NAME",               BDF_ATOM,     1, { 0 } },
-    { "ITALIC_ANGLE",            BDF_INTEGER,  1, { 0 } },
-    { "MAX_SPACE",               BDF_INTEGER,  1, { 0 } },
-    { "MIN_SPACE",               BDF_INTEGER,  1, { 0 } },
-    { "NORM_SPACE",              BDF_INTEGER,  1, { 0 } },
-    { "NOTICE",                  BDF_ATOM,     1, { 0 } },
-    { "PIXEL_SIZE",              BDF_INTEGER,  1, { 0 } },
-    { "POINT_SIZE",              BDF_INTEGER,  1, { 0 } },
-    { "QUAD_WIDTH",              BDF_INTEGER,  1, { 0 } },
-    { "RAW_ASCENT",              BDF_INTEGER,  1, { 0 } },
-    { "RAW_AVERAGE_WIDTH",       BDF_INTEGER,  1, { 0 } },
-    { "RAW_AVG_CAPITAL_WIDTH",   BDF_INTEGER,  1, { 0 } },
-    { "RAW_AVG_LOWERCASE_WIDTH", BDF_INTEGER,  1, { 0 } },
-    { "RAW_CAP_HEIGHT",          BDF_INTEGER,  1, { 0 } },
-    { "RAW_DESCENT",             BDF_INTEGER,  1, { 0 } },
-    { "RAW_END_SPACE",           BDF_INTEGER,  1, { 0 } },
-    { "RAW_FIGURE_WIDTH",        BDF_INTEGER,  1, { 0 } },
-    { "RAW_MAX_SPACE",           BDF_INTEGER,  1, { 0 } },
-    { "RAW_MIN_SPACE",           BDF_INTEGER,  1, { 0 } },
-    { "RAW_NORM_SPACE",          BDF_INTEGER,  1, { 0 } },
-    { "RAW_PIXEL_SIZE",          BDF_INTEGER,  1, { 0 } },
-    { "RAW_POINT_SIZE",          BDF_INTEGER,  1, { 0 } },
-    { "RAW_PIXELSIZE",           BDF_INTEGER,  1, { 0 } },
-    { "RAW_POINTSIZE",           BDF_INTEGER,  1, { 0 } },
-    { "RAW_QUAD_WIDTH",          BDF_INTEGER,  1, { 0 } },
-    { "RAW_SMALL_CAP_SIZE",      BDF_INTEGER,  1, { 0 } },
-    { "RAW_STRIKEOUT_ASCENT",    BDF_INTEGER,  1, { 0 } },
-    { "RAW_STRIKEOUT_DESCENT",   BDF_INTEGER,  1, { 0 } },
-    { "RAW_SUBSCRIPT_SIZE",      BDF_INTEGER,  1, { 0 } },
-    { "RAW_SUBSCRIPT_X",         BDF_INTEGER,  1, { 0 } },
-    { "RAW_SUBSCRIPT_Y",         BDF_INTEGER,  1, { 0 } },
-    { "RAW_SUPERSCRIPT_SIZE",    BDF_INTEGER,  1, { 0 } },
-    { "RAW_SUPERSCRIPT_X",       BDF_INTEGER,  1, { 0 } },
-    { "RAW_SUPERSCRIPT_Y",       BDF_INTEGER,  1, { 0 } },
-    { "RAW_UNDERLINE_POSITION",  BDF_INTEGER,  1, { 0 } },
-    { "RAW_UNDERLINE_THICKNESS", BDF_INTEGER,  1, { 0 } },
-    { "RAW_X_HEIGHT",            BDF_INTEGER,  1, { 0 } },
-    { "RELATIVE_SETWIDTH",       BDF_CARDINAL, 1, { 0 } },
-    { "RELATIVE_WEIGHT",         BDF_CARDINAL, 1, { 0 } },
-    { "RESOLUTION",              BDF_INTEGER,  1, { 0 } },
-    { "RESOLUTION_X",            BDF_CARDINAL, 1, { 0 } },
-    { "RESOLUTION_Y",            BDF_CARDINAL, 1, { 0 } },
-    { "SETWIDTH_NAME",           BDF_ATOM,     1, { 0 } },
-    { "SLANT",                   BDF_ATOM,     1, { 0 } },
-    { "SMALL_CAP_SIZE",          BDF_INTEGER,  1, { 0 } },
-    { "SPACING",                 BDF_ATOM,     1, { 0 } },
-    { "STRIKEOUT_ASCENT",        BDF_INTEGER,  1, { 0 } },
-    { "STRIKEOUT_DESCENT",       BDF_INTEGER,  1, { 0 } },
-    { "SUBSCRIPT_SIZE",          BDF_INTEGER,  1, { 0 } },
-    { "SUBSCRIPT_X",             BDF_INTEGER,  1, { 0 } },
-    { "SUBSCRIPT_Y",             BDF_INTEGER,  1, { 0 } },
-    { "SUPERSCRIPT_SIZE",        BDF_INTEGER,  1, { 0 } },
-    { "SUPERSCRIPT_X",           BDF_INTEGER,  1, { 0 } },
-    { "SUPERSCRIPT_Y",           BDF_INTEGER,  1, { 0 } },
-    { "UNDERLINE_POSITION",      BDF_INTEGER,  1, { 0 } },
-    { "UNDERLINE_THICKNESS",     BDF_INTEGER,  1, { 0 } },
-    { "WEIGHT",                  BDF_CARDINAL, 1, { 0 } },
-    { "WEIGHT_NAME",             BDF_ATOM,     1, { 0 } },
-    { "X_HEIGHT",                BDF_INTEGER,  1, { 0 } },
-    { "_MULE_BASELINE_OFFSET",   BDF_INTEGER,  1, { 0 } },
-    { "_MULE_RELATIVE_COMPOSE",  BDF_INTEGER,  1, { 0 } },
+    { (char *)"ADD_STYLE_NAME",          BDF_ATOM,     1, { 0 } },
+    { (char *)"AVERAGE_WIDTH",           BDF_INTEGER,  1, { 0 } },
+    { (char *)"AVG_CAPITAL_WIDTH",       BDF_INTEGER,  1, { 0 } },
+    { (char *)"AVG_LOWERCASE_WIDTH",     BDF_INTEGER,  1, { 0 } },
+    { (char *)"CAP_HEIGHT",              BDF_INTEGER,  1, { 0 } },
+    { (char *)"CHARSET_COLLECTIONS",     BDF_ATOM,     1, { 0 } },
+    { (char *)"CHARSET_ENCODING",        BDF_ATOM,     1, { 0 } },
+    { (char *)"CHARSET_REGISTRY",        BDF_ATOM,     1, { 0 } },
+    { (char *)"COMMENT",                 BDF_ATOM,     1, { 0 } },
+    { (char *)"COPYRIGHT",               BDF_ATOM,     1, { 0 } },
+    { (char *)"DEFAULT_CHAR",            BDF_CARDINAL, 1, { 0 } },
+    { (char *)"DESTINATION",             BDF_CARDINAL, 1, { 0 } },
+    { (char *)"DEVICE_FONT_NAME",        BDF_ATOM,     1, { 0 } },
+    { (char *)"END_SPACE",               BDF_INTEGER,  1, { 0 } },
+    { (char *)"FACE_NAME",               BDF_ATOM,     1, { 0 } },
+    { (char *)"FAMILY_NAME",             BDF_ATOM,     1, { 0 } },
+    { (char *)"FIGURE_WIDTH",            BDF_INTEGER,  1, { 0 } },
+    { (char *)"FONT",                    BDF_ATOM,     1, { 0 } },
+    { (char *)"FONTNAME_REGISTRY",       BDF_ATOM,     1, { 0 } },
+    { (char *)"FONT_ASCENT",             BDF_INTEGER,  1, { 0 } },
+    { (char *)"FONT_DESCENT",            BDF_INTEGER,  1, { 0 } },
+    { (char *)"FOUNDRY",                 BDF_ATOM,     1, { 0 } },
+    { (char *)"FULL_NAME",               BDF_ATOM,     1, { 0 } },
+    { (char *)"ITALIC_ANGLE",            BDF_INTEGER,  1, { 0 } },
+    { (char *)"MAX_SPACE",               BDF_INTEGER,  1, { 0 } },
+    { (char *)"MIN_SPACE",               BDF_INTEGER,  1, { 0 } },
+    { (char *)"NORM_SPACE",              BDF_INTEGER,  1, { 0 } },
+    { (char *)"NOTICE",                  BDF_ATOM,     1, { 0 } },
+    { (char *)"PIXEL_SIZE",              BDF_INTEGER,  1, { 0 } },
+    { (char *)"POINT_SIZE",              BDF_INTEGER,  1, { 0 } },
+    { (char *)"QUAD_WIDTH",              BDF_INTEGER,  1, { 0 } },
+    { (char *)"RAW_ASCENT",              BDF_INTEGER,  1, { 0 } },
+    { (char *)"RAW_AVERAGE_WIDTH",       BDF_INTEGER,  1, { 0 } },
+    { (char *)"RAW_AVG_CAPITAL_WIDTH",   BDF_INTEGER,  1, { 0 } },
+    { (char *)"RAW_AVG_LOWERCASE_WIDTH", BDF_INTEGER,  1, { 0 } },
+    { (char *)"RAW_CAP_HEIGHT",          BDF_INTEGER,  1, { 0 } },
+    { (char *)"RAW_DESCENT",             BDF_INTEGER,  1, { 0 } },
+    { (char *)"RAW_END_SPACE",           BDF_INTEGER,  1, { 0 } },
+    { (char *)"RAW_FIGURE_WIDTH",        BDF_INTEGER,  1, { 0 } },
+    { (char *)"RAW_MAX_SPACE",           BDF_INTEGER,  1, { 0 } },
+    { (char *)"RAW_MIN_SPACE",           BDF_INTEGER,  1, { 0 } },
+    { (char *)"RAW_NORM_SPACE",          BDF_INTEGER,  1, { 0 } },
+    { (char *)"RAW_PIXEL_SIZE",          BDF_INTEGER,  1, { 0 } },
+    { (char *)"RAW_POINT_SIZE",          BDF_INTEGER,  1, { 0 } },
+    { (char *)"RAW_PIXELSIZE",           BDF_INTEGER,  1, { 0 } },
+    { (char *)"RAW_POINTSIZE",           BDF_INTEGER,  1, { 0 } },
+    { (char *)"RAW_QUAD_WIDTH",          BDF_INTEGER,  1, { 0 } },
+    { (char *)"RAW_SMALL_CAP_SIZE",      BDF_INTEGER,  1, { 0 } },
+    { (char *)"RAW_STRIKEOUT_ASCENT",    BDF_INTEGER,  1, { 0 } },
+    { (char *)"RAW_STRIKEOUT_DESCENT",   BDF_INTEGER,  1, { 0 } },
+    { (char *)"RAW_SUBSCRIPT_SIZE",      BDF_INTEGER,  1, { 0 } },
+    { (char *)"RAW_SUBSCRIPT_X",         BDF_INTEGER,  1, { 0 } },
+    { (char *)"RAW_SUBSCRIPT_Y",         BDF_INTEGER,  1, { 0 } },
+    { (char *)"RAW_SUPERSCRIPT_SIZE",    BDF_INTEGER,  1, { 0 } },
+    { (char *)"RAW_SUPERSCRIPT_X",       BDF_INTEGER,  1, { 0 } },
+    { (char *)"RAW_SUPERSCRIPT_Y",       BDF_INTEGER,  1, { 0 } },
+    { (char *)"RAW_UNDERLINE_POSITION",  BDF_INTEGER,  1, { 0 } },
+    { (char *)"RAW_UNDERLINE_THICKNESS", BDF_INTEGER,  1, { 0 } },
+    { (char *)"RAW_X_HEIGHT",            BDF_INTEGER,  1, { 0 } },
+    { (char *)"RELATIVE_SETWIDTH",       BDF_CARDINAL, 1, { 0 } },
+    { (char *)"RELATIVE_WEIGHT",         BDF_CARDINAL, 1, { 0 } },
+    { (char *)"RESOLUTION",              BDF_INTEGER,  1, { 0 } },
+    { (char *)"RESOLUTION_X",            BDF_CARDINAL, 1, { 0 } },
+    { (char *)"RESOLUTION_Y",            BDF_CARDINAL, 1, { 0 } },
+    { (char *)"SETWIDTH_NAME",           BDF_ATOM,     1, { 0 } },
+    { (char *)"SLANT",                   BDF_ATOM,     1, { 0 } },
+    { (char *)"SMALL_CAP_SIZE",          BDF_INTEGER,  1, { 0 } },
+    { (char *)"SPACING",                 BDF_ATOM,     1, { 0 } },
+    { (char *)"STRIKEOUT_ASCENT",        BDF_INTEGER,  1, { 0 } },
+    { (char *)"STRIKEOUT_DESCENT",       BDF_INTEGER,  1, { 0 } },
+    { (char *)"SUBSCRIPT_SIZE",          BDF_INTEGER,  1, { 0 } },
+    { (char *)"SUBSCRIPT_X",             BDF_INTEGER,  1, { 0 } },
+    { (char *)"SUBSCRIPT_Y",             BDF_INTEGER,  1, { 0 } },
+    { (char *)"SUPERSCRIPT_SIZE",        BDF_INTEGER,  1, { 0 } },
+    { (char *)"SUPERSCRIPT_X",           BDF_INTEGER,  1, { 0 } },
+    { (char *)"SUPERSCRIPT_Y",           BDF_INTEGER,  1, { 0 } },
+    { (char *)"UNDERLINE_POSITION",      BDF_INTEGER,  1, { 0 } },
+    { (char *)"UNDERLINE_THICKNESS",     BDF_INTEGER,  1, { 0 } },
+    { (char *)"WEIGHT",                  BDF_CARDINAL, 1, { 0 } },
+    { (char *)"WEIGHT_NAME",             BDF_ATOM,     1, { 0 } },
+    { (char *)"X_HEIGHT",                BDF_INTEGER,  1, { 0 } },
+    { (char *)"_MULE_BASELINE_OFFSET",   BDF_INTEGER,  1, { 0 } },
+    { (char *)"_MULE_RELATIVE_COMPOSE",  BDF_INTEGER,  1, { 0 } },
   };
 
   static const unsigned long
@@ -168,60 +167,168 @@
                         sizeof ( _bdf_properties[0] );
 
 
-  /* An auxiliary macro to parse properties, to be used in conditionals. */
-  /* It behaves like `strncmp' but also tests the following character    */
-  /* whether it is a whitespace or NULL.                                 */
-  /* `property' is a constant string of length `n' to compare with.      */
-#define _bdf_strncmp( name, property, n )      \
-          ( ft_strncmp( name, property, n ) || \
-            !( name[n] == ' '  ||              \
-               name[n] == '\0' ||              \
-               name[n] == '\n' ||              \
-               name[n] == '\r' ||              \
-               name[n] == '\t' )            )
-
-  /* Auto correction messages. */
-#define ACMSG1   "FONT_ASCENT property missing.  " \
-                 "Added `FONT_ASCENT %hd'.\n"
-#define ACMSG2   "FONT_DESCENT property missing.  " \
-                 "Added `FONT_DESCENT %hd'.\n"
-#define ACMSG3   "Font width != actual width.  Old: %hd New: %hd.\n"
-#define ACMSG4   "Font left bearing != actual left bearing.  " \
-                 "Old: %hd New: %hd.\n"
-#define ACMSG5   "Font ascent != actual ascent.  Old: %hd New: %hd.\n"
-#define ACMSG6   "Font descent != actual descent.  Old: %hd New: %hd.\n"
-#define ACMSG7   "Font height != actual height. Old: %hd New: %hd.\n"
-#define ACMSG8   "Glyph scalable width (SWIDTH) adjustments made.\n"
-#define ACMSG9   "SWIDTH field missing at line %ld.  Set automatically.\n"
-#define ACMSG10  "DWIDTH field missing at line %ld.  Set to glyph width.\n"
-#define ACMSG11  "SIZE bits per pixel field adjusted to %hd.\n"
-#define ACMSG13  "Glyph %lu extra rows removed.\n"
-#define ACMSG14  "Glyph %lu extra columns removed.\n"
-#define ACMSG15  "Incorrect glyph count: %ld indicated but %ld found.\n"
-#define ACMSG16  "Glyph %lu missing columns padded with zero bits.\n"
-#define ACMSG17  "Adjusting number of glyphs to %ld.\n"
-
-  /* Error messages. */
-#define ERRMSG1  "[line %ld] Missing `%s' line.\n"
-#define ERRMSG2  "[line %ld] Font header corrupted or missing fields.\n"
-#define ERRMSG3  "[line %ld] Font glyphs corrupted or missing fields.\n"
-#define ERRMSG4  "[line %ld] BBX too big.\n"
-#define ERRMSG5  "[line %ld] `%s' value too big.\n"
-#define ERRMSG6  "[line %ld] Input line too long.\n"
-#define ERRMSG7  "[line %ld] Font name too long.\n"
-#define ERRMSG8  "[line %ld] Invalid `%s' value.\n"
-#define ERRMSG9  "[line %ld] Invalid keyword.\n"
-
-  /* Debug messages. */
-#define DBGMSG1  "  [%6ld] %s" /* no \n */
-#define DBGMSG2  " (0x%lX)\n"
-
-
-  /**************************************************************************
-   *
-   * Utility types and functions.
-   *
-   */
+  /*************************************************************************/
+  /*                                                                       */
+  /* Hash table utilities for the properties.                              */
+  /*                                                                       */
+  /*************************************************************************/
+
+  /* XXX: Replace this with FreeType's hash functions */
+
+
+#define INITIAL_HT_SIZE  241
+
+  typedef void
+  (*hash_free_func)( hashnode  node );
+
+  static hashnode*
+  hash_bucket( const char*  key,
+               hashtable*   ht )
+  {
+    const char*    kp  = key;
+    unsigned long  res = 0;
+    hashnode*      bp  = ht->table, *ndp;
+
+
+    /* Mocklisp hash function. */
+    while ( *kp )
+      res = ( res << 5 ) - res + *kp++;
+
+    ndp = bp + ( res % ht->size );
+    while ( *ndp )
+    {
+      kp = (*ndp)->key;
+      if ( kp[0] == key[0] && ft_strcmp( kp, key ) == 0 )
+        break;
+      ndp--;
+      if ( ndp < bp )
+        ndp = bp + ( ht->size - 1 );
+    }
+
+    return ndp;
+  }
+
+
+  static FT_Error
+  hash_rehash( hashtable*  ht,
+               FT_Memory   memory )
+  {
+    hashnode*  obp = ht->table, *bp, *nbp;
+    int        i, sz = ht->size;
+    FT_Error   error = BDF_Err_Ok;
+
+
+    ht->size <<= 1;
+    ht->limit  = ht->size / 3;
+
+    if ( FT_NEW_ARRAY( ht->table, ht->size ) )
+      goto Exit;
+
+    for ( i = 0, bp = obp; i < sz; i++, bp++ )
+    {
+      if ( *bp )
+      {
+        nbp = hash_bucket( (*bp)->key, ht );
+        *nbp = *bp;
+      }
+    }
+    FT_FREE( obp );
+
+  Exit:
+    return error;
+  }
+
+
+  static FT_Error
+  hash_init( hashtable*  ht,
+             FT_Memory   memory )
+  {
+    int       sz = INITIAL_HT_SIZE;
+    FT_Error  error = BDF_Err_Ok;
+
+
+    ht->size  = sz;
+    ht->limit = sz / 3;
+    ht->used  = 0;
+
+    if ( FT_NEW_ARRAY( ht->table, sz ) )
+      goto Exit;
+
+  Exit:
+    return error;
+  }
+
+
+  static void
+  hash_free( hashtable*  ht,
+             FT_Memory   memory )
+  {
+    if ( ht != 0 )
+    {
+      int        i, sz = ht->size;
+      hashnode*  bp = ht->table;
+
+
+      for ( i = 0; i < sz; i++, bp++ )
+        FT_FREE( *bp );
+
+      FT_FREE( ht->table );
+    }
+  }
+
+
+  static FT_Error
+  hash_insert( char*       key,
+               void*       data,
+               hashtable*  ht,
+               FT_Memory   memory )
+  {
+    hashnode  nn, *bp = hash_bucket( key, ht );
+    FT_Error  error = BDF_Err_Ok;
+
+
+    nn = *bp;
+    if ( !nn )
+    {
+      if ( FT_NEW( nn ) )
+        goto Exit;
+      *bp = nn;
+
+      nn->key  = key;
+      nn->data = data;
+
+      if ( ht->used >= ht->limit )
+      {
+        error = hash_rehash( ht, memory );
+        if ( error )
+          goto Exit;
+      }
+      ht->used++;
+    }
+    else
+      nn->data = data;
+
+  Exit:
+    return error;
+  }
+
+
+  static hashnode
+  hash_lookup( const char* key,
+               hashtable*  ht )
+  {
+    hashnode *np = hash_bucket( key, ht );
+
+
+    return *np;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Utility types and functions.                                          */
+  /*                                                                       */
+  /*************************************************************************/
 
 
   /* Function type for parsing lines of a BDF font. */
@@ -268,18 +375,19 @@
     bdf_font_t*     font;
     bdf_options_t*  opts;
 
+    unsigned long   have[2048];
     _bdf_list_t     list;
 
     FT_Memory       memory;
-    unsigned long   size;        /* the stream size */
 
+    int             binary_mode;
+    int             bitmap_bytes;
+    int             compact_tag;
   } _bdf_parse_t;
 
 
-#define setsbit( m, cc ) \
-          ( m[(FT_Byte)(cc) >> 3] |= (FT_Byte)( 1 << ( (cc) & 7 ) ) )
-#define sbitset( m, cc ) \
-          ( m[(FT_Byte)(cc) >> 3]  & ( 1 << ( (cc) & 7 ) ) )
+#define setsbit( m, cc )  ( m[(cc) >> 3] |= (FT_Byte)( 1 << ( (cc) & 7 ) ) )
+#define sbitset( m, cc )  ( m[(cc) >> 3]  & ( 1 << ( (cc) & 7 ) ) )
 
 
   static void
@@ -306,23 +414,23 @@
 
 
   static FT_Error
-  _bdf_list_ensure( _bdf_list_t*   list,
-                    unsigned long  num_items ) /* same as _bdf_list_t.used */
+  _bdf_list_ensure( _bdf_list_t*  list,
+                    int           num_items )
   {
-    FT_Error  error = FT_Err_Ok;
+    FT_Error  error = BDF_Err_Ok;
 
 
-    if ( num_items > list->size )
+    if ( num_items > (int)list->size )
     {
-      unsigned long  oldsize = list->size; /* same as _bdf_list_t.size */
-      unsigned long  newsize = oldsize + ( oldsize >> 1 ) + 5;
-      unsigned long  bigsize = (unsigned long)( FT_INT_MAX / sizeof ( char* ) );
-      FT_Memory      memory  = list->memory;
+      int        oldsize = list->size;
+      int        newsize = oldsize + ( oldsize >> 1 ) + 4;
+      int        bigsize = FT_INT_MAX / sizeof ( char* );
+      FT_Memory  memory  = list->memory;
 
 
       if ( oldsize == bigsize )
       {
-        error = FT_THROW( Out_Of_Memory );
+        error = BDF_Err_Out_Of_Memory;
         goto Exit;
       }
       else if ( newsize < oldsize || newsize > bigsize )
@@ -361,18 +469,13 @@
   }
 
 
-  /* An empty string for empty fields. */
-
-  static const char  empty[] = "";      /* XXX eliminate this */
-
-
   static char *
   _bdf_list_join( _bdf_list_t*    list,
                   int             c,
                   unsigned long  *alen )
   {
     unsigned long  i, j;
-    char*          dp;
+    char           *fp, *dp;
 
 
     *alen = 0;
@@ -383,51 +486,39 @@
     dp = list->field[0];
     for ( i = j = 0; i < list->used; i++ )
     {
-      char*  fp = list->field[i];
-
-
+      fp = list->field[i];
       while ( *fp )
         dp[j++] = *fp++;
 
       if ( i + 1 < list->used )
         dp[j++] = (char)c;
     }
-    if ( dp != empty )
-      dp[j] = 0;
+    dp[j] = 0;
 
     *alen = j;
     return dp;
   }
 
 
-  /* The code below ensures that we have at least 4 + 1 `field' */
-  /* elements in `list' (which are possibly NULL) so that we    */
-  /* don't have to check the number of fields in most cases.    */
+  /* An empty string for empty fields. */
+
+  static const char  empty[1] = { 0 };      /* XXX eliminate this */
+
 
   static FT_Error
   _bdf_list_split( _bdf_list_t*   list,
-                   const char*    separators,
+                   char*          separators,
                    char*          line,
                    unsigned long  linelen )
   {
-    unsigned long  final_empty;
-    int            mult;
-    const char     *sp, *end;
-    char           *ep;
-    char           seps[32];
-    FT_Error       error = FT_Err_Ok;
+    int       mult, final_empty;
+    char      *sp, *ep, *end;
+    char      seps[32];
+    FT_Error  error = BDF_Err_Ok;
 
 
     /* Initialize the list. */
     list->used = 0;
-    if ( list->size )
-    {
-      list->field[0] = (char*)empty;
-      list->field[1] = (char*)empty;
-      list->field[2] = (char*)empty;
-      list->field[3] = (char*)empty;
-      list->field[4] = (char*)empty;
-    }
 
     /* If the line is empty, then simply return. */
     if ( linelen == 0 || line[0] == 0 )
@@ -438,7 +529,7 @@
     /* this, so an error is signaled.                                 */
     if ( separators == 0 || *separators == 0 )
     {
-      error = FT_THROW( Invalid_Argument );
+      error = BDF_Err_Invalid_Argument;
       goto Exit;
     }
 
@@ -473,7 +564,7 @@
       }
 
       /* Assign the field appropriately. */
-      list->field[list->used++] = ( ep > sp ) ? (char*)sp : (char*)empty;
+      list->field[list->used++] = ( ep > sp ) ? sp : (char*)empty;
 
       sp = ep;
 
@@ -522,16 +613,17 @@
   {
     _bdf_line_func_t  cb;
     unsigned long     lineno, buf_size;
-    int               refill, hold, to_skip;
-    ptrdiff_t         bytes, start, end, cursor, avail;
-    char*             buf    = NULL;
+    int               refill, bytes, hold, to_skip;
+    int               start, end, cursor, avail;
+    char*             buf = 0;
     FT_Memory         memory = stream->memory;
-    FT_Error          error  = FT_Err_Ok;
+    FT_Error          error = BDF_Err_Ok;
 
+    int               byte_count = 0;
 
     if ( callback == 0 )
     {
-      error = FT_THROW( Invalid_Argument );
+      error = BDF_Err_Invalid_Argument;
       goto Exit;
     }
 
@@ -545,6 +637,7 @@
     lineno  = 1;
     buf[0]  = 0;
     start   = 0;
+    end     = 0;
     avail   = 0;
     cursor  = 0;
     refill  = 1;
@@ -555,27 +648,55 @@
     {
       if ( refill )
       {
-        bytes  = (ptrdiff_t)FT_Stream_TryRead(
-                   stream, (FT_Byte*)buf + cursor,
-                   buf_size - (unsigned long)cursor );
+        bytes  = (int)FT_Stream_TryRead( stream, (FT_Byte*)buf + cursor,
+                                         (FT_ULong)(buf_size - cursor) );
         avail  = cursor + bytes;
+
+        end = cursor;
+        
         cursor = 0;
         refill = 0;
       }
+      else
+      {
+        end = start;
+      }
 
-      end = start;
-
-      /* should we skip an optional character like \n or \r? */
-      if ( start < avail && buf[start] == to_skip )
+      /* should we skip an optional character like \n or \r? (only do this for non-binary mode) */
+      if (!(((_bdf_parse_t *)client_data)->binary_mode == 1))
       {
-        start  += 1;
-        to_skip = NO_SKIP;
-        continue;
+          if ( start < avail && buf[start] == to_skip )
+          {
+            start  += 1;
+            to_skip = NO_SKIP;
+            continue;
+          }
       }
 
-      /* try to find the end of the line */
-      while ( end < avail && buf[end] != '\n' && buf[end] != '\r' )
-        end++;
+      if (((_bdf_parse_t *)client_data)->compact_tag == 1)
+      {
+          /* try to find the end of the line */
+          if (((_bdf_parse_t *)client_data)->binary_mode == 1)
+          {
+            /* In the binary mode, the end of line should not be simply detected by watching '\n' or '\r' */
+            while (end < avail && byte_count > 0)
+            {
+                end++;
+                byte_count--;
+            }
+          }
+          else
+          {
+            while ( end < avail && buf[end] != '\n' && buf[end] != '\r' )
+              end++;
+          }
+      }
+      else
+      {
+          /* try to find the end of the line */
+          while ( end < avail && buf[end] != '\n' && buf[end] != '\r' )
+            end++;
+      }
 
       /* if we hit the end of the buffer, try shifting its content */
       /* or even resizing it                                       */
@@ -593,8 +714,7 @@
 
           if ( buf_size >= 65536UL )  /* limit ourselves to 64KByte */
           {
-            FT_ERROR(( "_bdf_readstream: " ERRMSG6, lineno ));
-            error = FT_THROW( Invalid_Argument );
+            error = BDF_Err_Invalid_Argument;
             goto Exit;
           }
 
@@ -602,14 +722,14 @@
           if ( FT_RENEW_ARRAY( buf, buf_size, new_size ) )
             goto Exit;
 
-          cursor   = (ptrdiff_t)buf_size;
+          cursor   = buf_size;
           buf_size = new_size;
         }
         else
         {
           bytes = avail - start;
 
-          FT_MEM_MOVE( buf, buf + start, bytes );
+          FT_MEM_COPY( buf, buf + start, bytes );
 
           cursor = bytes;
           avail -= bytes;
@@ -623,19 +743,29 @@
       hold     = buf[end];
       buf[end] = 0;
 
-      /* XXX: Use encoding independent value for 0x1A */
-      if ( buf[start] != '#' && buf[start] != 0x1A && end > start )
+      /* XXX: Use encoding independent value for 0x1a */
+      /* this sould only be checked in the non-binary mode */
+      if (((((_bdf_parse_t *)client_data)->binary_mode == 1) || (buf[start] != '#' && buf[start] != 0x1a)) && (end > start))
       {
-        error = (*cb)( buf + start, (unsigned long)( end - start ), lineno,
+        error = (*cb)( buf + start, end - start, lineno,
                        (void*)&cb, client_data );
-        /* Redo if we have encountered CHARS without properties. */
-        if ( error == -1 )
-          error = (*cb)( buf + start, (unsigned long)( end - start ), lineno,
-                         (void*)&cb, client_data );
         if ( error )
           break;
       }
 
+      if (((_bdf_parse_t *)client_data)->compact_tag == 1)
+      {
+          if (((_bdf_parse_t *)client_data)->binary_mode == 1)
+          {
+            byte_count = ((_bdf_parse_t *)client_data)->bitmap_bytes;
+
+            if (byte_count == 0)
+            {
+                ((_bdf_parse_t *)client_data)->binary_mode = 0;
+            }
+          }
+      }
+
       lineno  += 1;
       buf[end] = (char)hold;
       start    = end + 1;
@@ -665,17 +795,25 @@
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
   };
 
+  static const unsigned char  odigits[32] =
+  {
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  };
+
   static const unsigned char  ddigits[32] =
   {
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x03,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
@@ -683,48 +821,91 @@
 
   static const unsigned char  hdigits[32] =
   {
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03,
-    0x7E, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x03,
+    0x7e, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   };
 
 
-  /* Routine to convert a decimal ASCII string to an unsigned long integer. */
+#define isdigok( m, d )  (m[(d) >> 3] & ( 1 << ( (d) & 7 ) ) )
+
+
+  /* Routine to convert an ASCII string into an unsigned long integer. */
   static unsigned long
-  _bdf_atoul( const char*  s )
+  _bdf_atoul( char*   s,
+              char**  end,
+              int     base )
   {
-    unsigned long  v;
+    unsigned long         v;
+    const unsigned char*  dmap;
 
 
     if ( s == 0 || *s == 0 )
       return 0;
 
-    for ( v = 0; sbitset( ddigits, *s ); s++ )
+    /* Make sure the radix is something recognizable.  Default to 10. */
+    switch ( base )
     {
-      if ( v < ( FT_ULONG_MAX - 9 ) / 10 )
-        v = v * 10 + a2i[(int)*s];
-      else
-      {
-        v = FT_ULONG_MAX;
-        break;
-      }
+    case 8:
+      dmap = odigits;
+      break;
+    case 16:
+      dmap = hdigits;
+      break;
+    default:
+      base = 10;
+      dmap = ddigits;
+      break;
     }
 
+    /* Check for the special hex prefix. */
+    if ( *s == '0'                                  &&
+         ( *( s + 1 ) == 'x' || *( s + 1 ) == 'X' ) )
+    {
+      base = 16;
+      dmap = hdigits;
+      s   += 2;
+    }
+
+    for ( v = 0; isdigok( dmap, *s ); s++ )
+      v = v * base + a2i[(int)*s];
+
+    if ( end != 0 )
+      *end = s;
+
     return v;
   }
 
 
-  /* Routine to convert a decimal ASCII string to a signed long integer. */
+  /* Routine to convert an ASCII string into an signed long integer. */
   static long
-  _bdf_atol( const char*  s )
+  _bdf_atol( char*   s,
+             char**  end,
+             int     base )
   {
-    long  v, neg;
+    long                  v, neg;
+    const unsigned char*  dmap;
 
 
     if ( s == 0 || *s == 0 )
       return 0;
 
+    /* Make sure the radix is something recognizable.  Default to 10. */
+    switch ( base )
+    {
+    case 8:
+      dmap = odigits;
+      break;
+    case 16:
+      dmap = hdigits;
+      break;
+    default:
+      base = 10;
+      dmap = ddigits;
+      break;
+    }
+
     /* Check for a minus sign. */
     neg = 0;
     if ( *s == '-' )
@@ -733,56 +914,53 @@
       neg = 1;
     }
 
-    for ( v = 0; sbitset( ddigits, *s ); s++ )
+    /* Check for the special hex prefix. */
+    if ( *s == '0'                                  &&
+         ( *( s + 1 ) == 'x' || *( s + 1 ) == 'X' ) )
     {
-      if ( v < ( FT_LONG_MAX - 9 ) / 10 )
-        v = v * 10 + a2i[(int)*s];
-      else
-      {
-        v = FT_LONG_MAX;
-        break;
-      }
+      base = 16;
+      dmap = hdigits;
+      s   += 2;
     }
 
-    return ( !neg ) ? v : -v;
-  }
-
-
-  /* Routine to convert a decimal ASCII string to an unsigned short integer. */
-  static unsigned short
-  _bdf_atous( const char*  s )
-  {
-    unsigned short  v;
+    for ( v = 0; isdigok( dmap, *s ); s++ )
+      v = v * base + a2i[(int)*s];
 
+    if ( end != 0 )
+      *end = s;
 
-    if ( s == 0 || *s == 0 )
-      return 0;
-
-    for ( v = 0; sbitset( ddigits, *s ); s++ )
-    {
-      if ( v < ( FT_USHORT_MAX - 9 ) / 10 )
-        v = (unsigned short)( v * 10 + a2i[(int)*s] );
-      else
-      {
-        v = FT_USHORT_MAX;
-        break;
-      }
-    }
-
-    return v;
+    return ( !neg ) ? v : -v;
   }
 
 
   /* Routine to convert a decimal ASCII string to a signed short integer. */
   static short
-  _bdf_atos( const char*  s )
+  _bdf_atos( char*   s,
+             char**  end,
+             int     base )
   {
-    short  v, neg;
+    short                 v, neg;
+    const unsigned char*  dmap;
 
 
     if ( s == 0 || *s == 0 )
       return 0;
 
+    /* Make sure the radix is something recognizable.  Default to 10. */
+    switch ( base )
+    {
+    case 8:
+      dmap = odigits;
+      break;
+    case 16:
+      dmap = hdigits;
+      break;
+    default:
+      base = 10;
+      dmap = ddigits;
+      break;
+    }
+
     /* Check for a minus. */
     neg = 0;
     if ( *s == '-' )
@@ -791,17 +969,21 @@
       neg = 1;
     }
 
-    for ( v = 0; sbitset( ddigits, *s ); s++ )
+    /* Check for the special hex prefix. */
+    if ( *s == '0'                                  &&
+         ( *( s + 1 ) == 'x' || *( s + 1 ) == 'X' ) )
     {
-      if ( v < ( SHRT_MAX - 9 ) / 10 )
-        v = (short)( v * 10 + a2i[(int)*s] );
-      else
-      {
-        v = SHRT_MAX;
-        break;
-      }
+      base = 16;
+      dmap = hdigits;
+      s   += 2;
     }
 
+    for ( v = 0; isdigok( dmap, *s ); s++ )
+      v = (short)( v * base + a2i[(int)*s] );
+
+    if ( end != 0 )
+      *end = s;
+
     return (short)( ( !neg ) ? v : -v );
   }
 
@@ -828,7 +1010,7 @@
 
 
   static FT_Error
-  bdf_create_property( const char*  name,
+  bdf_create_property( char*        name,
                        int          format,
                        bdf_font_t*  font )
   {
@@ -866,7 +1048,7 @@
 
     n = _num_bdf_properties + font->nuser_props;
 
-    error = ft_hash_str_insert( p->name, n, &(font->proptbl), memory );
+    error = hash_insert( p->name, (void *)n, &(font->proptbl), memory );
     if ( error )
       goto Exit;
 
@@ -881,55 +1063,57 @@
   bdf_get_property( char*        name,
                     bdf_font_t*  font )
   {
-    size_t*  propid;
+    hashnode       hn;
+    unsigned long  propid;
 
 
     if ( name == 0 || *name == 0 )
       return 0;
 
-    if ( ( propid = ft_hash_str_lookup( name, &(font->proptbl) ) ) == NULL )
+    if ( ( hn = hash_lookup( name, &(font->proptbl) ) ) == 0 )
       return 0;
 
-    if ( *propid >= _num_bdf_properties )
-      return font->user_props + ( *propid - _num_bdf_properties );
+    propid = (unsigned long)hn->data;
+    if ( propid >= _num_bdf_properties )
+      return font->user_props + ( propid - _num_bdf_properties );
 
-    return (bdf_property_t*)_bdf_properties + *propid;
+    return (bdf_property_t*)_bdf_properties + propid;
   }
 
 
-  /**************************************************************************
-   *
-   * BDF font file parsing flags and functions.
-   *
-   */
+  /*************************************************************************/
+  /*                                                                       */
+  /* BDF font file parsing flags and functions.                            */
+  /*                                                                       */
+  /*************************************************************************/
 
 
   /* Parse flags. */
 
-#define BDF_START_      0x0001U
-#define BDF_FONT_NAME_  0x0002U
-#define BDF_SIZE_       0x0004U
-#define BDF_FONT_BBX_   0x0008U
-#define BDF_PROPS_      0x0010U
-#define BDF_GLYPHS_     0x0020U
-#define BDF_GLYPH_      0x0040U
-#define BDF_ENCODING_   0x0080U
-#define BDF_SWIDTH_     0x0100U
-#define BDF_DWIDTH_     0x0200U
-#define BDF_BBX_        0x0400U
-#define BDF_BITMAP_     0x0800U
-
-#define BDF_SWIDTH_ADJ_  0x1000U
-
-#define BDF_GLYPH_BITS_ ( BDF_GLYPH_    | \
-                          BDF_ENCODING_ | \
-                          BDF_SWIDTH_   | \
-                          BDF_DWIDTH_   | \
-                          BDF_BBX_      | \
-                          BDF_BITMAP_   )
+#define _BDF_START      0x0001
+#define _BDF_FONT_NAME  0x0002
+#define _BDF_SIZE       0x0004
+#define _BDF_FONT_BBX   0x0008
+#define _BDF_PROPS      0x0010
+#define _BDF_GLYPHS     0x0020
+#define _BDF_GLYPH      0x0040
+#define _BDF_ENCODING   0x0080
+#define _BDF_SWIDTH     0x0100
+#define _BDF_DWIDTH     0x0200
+#define _BDF_BBX        0x0400
+#define _BDF_BITMAP     0x0800
+
+#define _BDF_SWIDTH_ADJ  0x1000
+
+#define _BDF_GLYPH_BITS ( _BDF_GLYPH    | \
+                          _BDF_ENCODING | \
+                          _BDF_SWIDTH   | \
+                          _BDF_DWIDTH   | \
+                          _BDF_BBX      | \
+                          _BDF_BITMAP   )
 
-#define BDF_GLYPH_WIDTH_CHECK_   0x40000000UL
-#define BDF_GLYPH_HEIGHT_CHECK_  0x80000000UL
+#define _BDF_GLYPH_WIDTH_CHECK   0x40000000L
+#define _BDF_GLYPH_HEIGHT_CHECK  0x80000000L
 
 
   static FT_Error
@@ -998,7 +1182,7 @@
 
     FT_MEM_COPY( name, font->name, len );
 
-    error = _bdf_list_split( &list, "-", name, (unsigned long)len );
+    error = _bdf_list_split( &list, (char *)"-", name, (unsigned long)len );
     if ( error )
       goto Fail;
 
@@ -1096,26 +1280,24 @@
 
 
   static FT_Error
-  _bdf_add_property( bdf_font_t*    font,
-                     const char*    name,
-                     char*          value,
-                     unsigned long  lineno )
-  {
-    size_t*         propid;
+  _bdf_add_property( bdf_font_t*  font,
+                     char*        name,
+                     char*        value )
+  {
+    unsigned long   propid;
+    hashnode        hn;
+    int             len;
     bdf_property_t  *prop, *fp;
     FT_Memory       memory = font->memory;
-    FT_Error        error  = FT_Err_Ok;
+    FT_Error        error = BDF_Err_Ok;
 
-    FT_UNUSED( lineno );        /* only used in debug mode */
 
-
-    /* First, check whether the property already exists in the font. */
-    if ( ( propid = ft_hash_str_lookup( name,
-                                        (FT_Hash)font->internal ) ) != NULL )
+    /* First, check to see if the property already exists in the font. */
+    if ( ( hn = hash_lookup( name, (hashtable *)font->internal ) ) != 0 )
     {
       /* The property already exists in the font, so simply replace */
       /* the value of the property with the current value.          */
-      fp = font->props + *propid;
+      fp = font->props + (unsigned long)hn->data;
 
       switch ( fp->format )
       {
@@ -1123,19 +1305,27 @@
         /* Delete the current atom if it exists. */
         FT_FREE( fp->value.atom );
 
-        if ( value && value[0] != 0 )
+        if ( value == 0 )
+          len = 1;
+        else
+          len = ft_strlen( value ) + 1;
+
+        if ( len > 1 )
         {
-          if ( FT_STRDUP( fp->value.atom, value ) )
+          if ( FT_NEW_ARRAY( fp->value.atom, len ) )
             goto Exit;
+          FT_MEM_COPY( fp->value.atom, value, len );
         }
+        else
+          fp->value.atom = 0;
         break;
 
       case BDF_INTEGER:
-        fp->value.l = _bdf_atol( value );
+        fp->value.int32 = _bdf_atol( value, 0, 10 );
         break;
 
       case BDF_CARDINAL:
-        fp->value.ul = _bdf_atoul( value );
+        fp->value.card32 = _bdf_atoul( value, 0, 10 );
         break;
 
       default:
@@ -1147,16 +1337,16 @@
 
     /* See whether this property type exists yet or not. */
     /* If not, create it.                                */
-    propid = ft_hash_str_lookup( name, &(font->proptbl) );
-    if ( !propid )
+    hn = hash_lookup( name, &(font->proptbl) );
+    if ( hn == 0 )
     {
       error = bdf_create_property( name, BDF_ATOM, font );
       if ( error )
         goto Exit;
-      propid = ft_hash_str_lookup( name, &(font->proptbl) );
+      hn = hash_lookup( name, &(font->proptbl) );
     }
 
-    /* Allocate another property if this is overflowing. */
+    /* Allocate another property if this is overflow. */
     if ( font->props_used == font->props_size )
     {
       if ( font->props_size == 0 )
@@ -1173,14 +1363,15 @@
       }
 
       fp = font->props + font->props_size;
-      FT_ZERO( fp );
+      FT_MEM_ZERO( fp, sizeof ( bdf_property_t ) );
       font->props_size++;
     }
 
-    if ( *propid >= _num_bdf_properties )
-      prop = font->user_props + ( *propid - _num_bdf_properties );
+    propid = (unsigned long)hn->data;
+    if ( propid >= _num_bdf_properties )
+      prop = font->user_props + ( propid - _num_bdf_properties );
     else
-      prop = (bdf_property_t*)_bdf_properties + *propid;
+      prop = (bdf_property_t*)_bdf_properties + propid;
 
     fp = font->props + font->props_used;
 
@@ -1191,32 +1382,38 @@
     switch ( prop->format )
     {
     case BDF_ATOM:
-      fp->value.atom = 0;
-      if ( value != 0 && value[0] )
+      if ( value == 0 )
+        len = 1;
+      else
+        len = ft_strlen( value ) + 1;
+
+      if ( len > 1 )
       {
-        if ( FT_STRDUP( fp->value.atom, value ) )
+        if ( FT_NEW_ARRAY( fp->value.atom, len ) )
           goto Exit;
+        FT_MEM_COPY( fp->value.atom, value, len );
       }
+      else
+        fp->value.atom = 0;
       break;
 
     case BDF_INTEGER:
-      fp->value.l = _bdf_atol( value );
+      fp->value.int32 = _bdf_atol( value, 0, 10 );
       break;
 
     case BDF_CARDINAL:
-      fp->value.ul = _bdf_atoul( value );
+      fp->value.card32 = _bdf_atoul( value, 0, 10 );
       break;
     }
 
     /* If the property happens to be a comment, then it doesn't need */
     /* to be added to the internal hash table.                       */
-    if ( _bdf_strncmp( name, "COMMENT", 7 ) != 0 )
-    {
+    if ( ft_memcmp( name, "COMMENT", 7 ) != 0 ) {
       /* Add the property to the font property table. */
-      error = ft_hash_str_insert( fp->name,
-                                  font->props_used,
-                                  (FT_Hash)font->internal,
-                                  memory );
+      error = hash_insert( fp->name,
+                           (void *)font->props_used,
+                           (hashtable *)font->internal,
+                           memory );
       if ( error )
         goto Exit;
     }
@@ -1228,21 +1425,14 @@
     /* FONT_ASCENT and FONT_DESCENT need to be assigned if they are        */
     /* present, and the SPACING property should override the default       */
     /* spacing.                                                            */
-    if ( _bdf_strncmp( name, "DEFAULT_CHAR", 12 ) == 0 )
-      font->default_char = fp->value.ul;
-    else if ( _bdf_strncmp( name, "FONT_ASCENT", 11 ) == 0 )
-      font->font_ascent = fp->value.l;
-    else if ( _bdf_strncmp( name, "FONT_DESCENT", 12 ) == 0 )
-      font->font_descent = fp->value.l;
-    else if ( _bdf_strncmp( name, "SPACING", 7 ) == 0 )
+    if ( ft_memcmp( name, "DEFAULT_CHAR", 12 ) == 0 )
+      font->default_char = fp->value.int32;
+    else if ( ft_memcmp( name, "FONT_ASCENT", 11 ) == 0 )
+      font->font_ascent = fp->value.int32;
+    else if ( ft_memcmp( name, "FONT_DESCENT", 12 ) == 0 )
+      font->font_descent = fp->value.int32;
+    else if ( ft_memcmp( name, "SPACING", 7 ) == 0 )
     {
-      if ( !fp->value.atom )
-      {
-        FT_ERROR(( "_bdf_add_property: " ERRMSG8, lineno, "SPACING" ));
-        error = FT_THROW( Invalid_File_Format );
-        goto Exit;
-      }
-
       if ( fp->value.atom[0] == 'p' || fp->value.atom[0] == 'P' )
         font->spacing = BDF_PROPORTIONAL;
       else if ( fp->value.atom[0] == 'm' || fp->value.atom[0] == 'M' )
@@ -1262,25 +1452,6 @@
   };
 
 
-  static FT_Error
-  _bdf_parse_end( char*          line,
-                  unsigned long  linelen,
-                  unsigned long  lineno,
-                  void*          call_data,
-                  void*          client_data )
-  {
-    /* a no-op; we ignore everything after `ENDFONT' */
-
-    FT_UNUSED( line );
-    FT_UNUSED( linelen );
-    FT_UNUSED( lineno );
-    FT_UNUSED( call_data );
-    FT_UNUSED( client_data );
-
-    return FT_Err_Ok;
-  }
-
-
   /* Actually parse the glyph info and bitmaps. */
   static FT_Error
   _bdf_parse_glyphs( char*          line,
@@ -1294,7 +1465,6 @@
     unsigned char*     bp;
     unsigned long      i, slen, nibbles;
 
-    _bdf_line_func_t*  next;
     _bdf_parse_t*      p;
     bdf_glyph_t*       glyph;
     bdf_font_t*        font;
@@ -1302,17 +1472,17 @@
     FT_Memory          memory;
     FT_Error           error = FT_Err_Ok;
 
+    FT_UNUSED( call_data );
     FT_UNUSED( lineno );        /* only used in debug mode */
 
 
-    next = (_bdf_line_func_t *)call_data;
-    p    = (_bdf_parse_t *)    client_data;
+    p = (_bdf_parse_t *)client_data;
 
     font   = p->font;
     memory = font->memory;
 
     /* Check for a comment. */
-    if ( _bdf_strncmp( line, "COMMENT", 7 ) == 0 )
+    if ( ft_memcmp( line, "COMMENT", 7 ) == 0 )
     {
       linelen -= 7;
 
@@ -1326,104 +1496,78 @@
       goto Exit;
     }
 
+    /* check if the compact tag exist? */
+    if (ft_memcmp( line, "COMPACT_TAG", 11) == 0 )
+    {
+        p->compact_tag = 1;
+        goto Exit;
+    }
+
     /* The very first thing expected is the number of glyphs. */
-    if ( !( p->flags & BDF_GLYPHS_ ) )
+    if ( !( p->flags & _BDF_GLYPHS ) )
     {
-      if ( _bdf_strncmp( line, "CHARS", 5 ) != 0 )
+      if ( ft_memcmp( line, "CHARS", 5 ) != 0 )
       {
         FT_ERROR(( "_bdf_parse_glyphs: " ERRMSG1, lineno, "CHARS" ));
-        error = FT_THROW( Missing_Chars_Field );
+        error = BDF_Err_Missing_Chars_Field;
         goto Exit;
       }
 
-      error = _bdf_list_split( &p->list, " +", line, linelen );
+      error = _bdf_list_split( &p->list, (char *)" +", line, linelen );
       if ( error )
         goto Exit;
-      p->cnt = font->glyphs_size = _bdf_atoul( p->list.field[1] );
-
-      /* We need at least 20 bytes per glyph. */
-      if ( p->cnt > p->size / 20 )
-      {
-        p->cnt = font->glyphs_size = p->size / 20;
-        FT_TRACE2(( "_bdf_parse_glyphs: " ACMSG17, p->cnt ));
-      }
+      p->cnt = font->glyphs_size = _bdf_atoul( p->list.field[1], 0, 10 );
 
       /* Make sure the number of glyphs is non-zero. */
       if ( p->cnt == 0 )
         font->glyphs_size = 64;
 
-      /* Limit ourselves to 1,114,112 glyphs in the font (this is the */
-      /* number of code points available in Unicode).                 */
-      if ( p->cnt >= 0x110000UL )
-      {
-        FT_ERROR(( "_bdf_parse_glyphs: " ERRMSG5, lineno, "CHARS" ));
-        error = FT_THROW( Invalid_Argument );
-        goto Exit;
-      }
-
       if ( FT_NEW_ARRAY( font->glyphs, font->glyphs_size ) )
         goto Exit;
 
-      p->flags |= BDF_GLYPHS_;
+      p->flags |= _BDF_GLYPHS;
 
       goto Exit;
     }
 
     /* Check for the ENDFONT field. */
-    if ( _bdf_strncmp( line, "ENDFONT", 7 ) == 0 )
+    if ( ft_memcmp( line, "ENDFONT", 7 ) == 0 )
     {
-      if ( p->flags & BDF_GLYPH_BITS_ )
-      {
-        /* Missing ENDCHAR field. */
-        FT_ERROR(( "_bdf_parse_glyphs: " ERRMSG1, lineno, "ENDCHAR" ));
-        error = FT_THROW( Corrupted_Font_Glyphs );
-        goto Exit;
-      }
-
       /* Sort the glyphs by encoding. */
       ft_qsort( (char *)font->glyphs,
                 font->glyphs_used,
                 sizeof ( bdf_glyph_t ),
                 by_encoding );
 
-      p->flags &= ~BDF_START_;
-      *next     = _bdf_parse_end;
+      p->flags &= ~_BDF_START;
 
       goto Exit;
     }
 
     /* Check for the ENDCHAR field. */
-    if ( _bdf_strncmp( line, "ENDCHAR", 7 ) == 0 )
+    if ( (p->compact_tag == 1 && ft_memcmp( line, "R", 1 ) == 0) || (p->compact_tag == 0 && ft_memcmp( line, "ENDCHAR", 7 ) == 0))
     {
       p->glyph_enc = 0;
-      p->flags    &= ~BDF_GLYPH_BITS_;
+      p->flags    &= ~_BDF_GLYPH_BITS;
 
       goto Exit;
     }
 
-    /* Check whether a glyph is being scanned but should be */
-    /* ignored because it is an unencoded glyph.            */
-    if ( ( p->flags & BDF_GLYPH_ )     &&
+    /* Check to see whether a glyph is being scanned but should be */
+    /* ignored because it is an unencoded glyph.                   */
+    if ( ( p->flags & _BDF_GLYPH )     &&
          p->glyph_enc            == -1 &&
          p->opts->keep_unencoded == 0  )
       goto Exit;
 
     /* Check for the STARTCHAR field. */
-    if ( _bdf_strncmp( line, "STARTCHAR", 9 ) == 0 )
+    if ( (p->compact_tag == 1 && ft_memcmp( line, "S", 1 ) == 0) || (p->compact_tag == 0 && ft_memcmp( line, "STARTCHAR", 9 ) == 0))
     {
-      if ( p->flags & BDF_GLYPH_BITS_ )
-      {
-        /* Missing ENDCHAR field. */
-        FT_ERROR(( "_bdf_parse_glyphs: " ERRMSG1, lineno, "ENDCHAR" ));
-        error = FT_THROW( Missing_Startchar_Field );
-        goto Exit;
-      }
-
       /* Set the character name in the parse info first until the */
       /* encoding can be checked for an unencoded character.      */
       FT_FREE( p->glyph_name );
 
-      error = _bdf_list_split( &p->list, " +", line, linelen );
+      error = _bdf_list_split( &p->list, (char *)" +", line, linelen );
       if ( error )
         goto Exit;
 
@@ -1443,7 +1587,7 @@
 
       FT_MEM_COPY( p->glyph_name, s, slen + 1 );
 
-      p->flags |= BDF_GLYPH_;
+      p->flags |= _BDF_GLYPH;
 
       FT_TRACE4(( DBGMSG1, lineno, s ));
 
@@ -1451,35 +1595,39 @@
     }
 
     /* Check for the ENCODING field. */
-    if ( _bdf_strncmp( line, "ENCODING", 8 ) == 0 )
+    if ( (p->compact_tag == 1 && ft_memcmp( line, "E", 1 ) == 0) || (p->compact_tag == 0 && ft_memcmp( line, "ENCODING", 8 ) == 0))
     {
-      if ( !( p->flags & BDF_GLYPH_ ) )
+      if ( !( p->flags & _BDF_GLYPH ) )
       {
         /* Missing STARTCHAR field. */
         FT_ERROR(( "_bdf_parse_glyphs: " ERRMSG1, lineno, "STARTCHAR" ));
-        error = FT_THROW( Missing_Startchar_Field );
+        error = BDF_Err_Missing_Startchar_Field;
         goto Exit;
       }
 
-      error = _bdf_list_split( &p->list, " +", line, linelen );
+      error = _bdf_list_split( &p->list, (char *)" +", line, linelen );
       if ( error )
         goto Exit;
 
-      p->glyph_enc = _bdf_atol( p->list.field[1] );
+      p->glyph_enc = _bdf_atol( p->list.field[1], 0, 10 );
 
-      /* Normalize negative encoding values.  The specification only */
-      /* allows -1, but we can be more generous here.                */
-      if ( p->glyph_enc < -1 )
-        p->glyph_enc = -1;
-
-      /* Check for alternative encoding format. */
-      if ( p->glyph_enc == -1 && p->list.used > 2 )
-        p->glyph_enc = _bdf_atol( p->list.field[2] );
-
-      if ( p->glyph_enc < -1 || p->glyph_enc >= 0x110000L )
-        p->glyph_enc = -1;
-
-      FT_TRACE4(( DBGMSG2, p->glyph_enc ));
+      /* Check whether this encoding has already been encountered. */
+      /* If it has then change it to unencoded so it gets added if */
+      /* indicated.                                                */
+      if ( p->glyph_enc >= 0 )
+      {
+        if ( _bdf_glyph_modified( p->have, p->glyph_enc ) )
+        {
+          /* Emit a message saying a glyph has been moved to the */
+          /* unencoded area.                                     */
+          FT_TRACE2(( "_bdf_parse_glyphs: " ACMSG12,
+                      p->glyph_enc, p->glyph_name ));
+          p->glyph_enc = -1;
+          font->modified = 1;
+        }
+        else
+          _bdf_set_glyph_modified( p->have, p->glyph_enc );
+      }
 
       if ( p->glyph_enc >= 0 )
       {
@@ -1497,7 +1645,7 @@
 
         glyph           = font->glyphs + font->glyphs_used++;
         glyph->name     = p->glyph_name;
-        glyph->encoding = (unsigned long)p->glyph_enc;
+        glyph->encoding = p->glyph_enc;
 
         /* Reset the initial glyph info. */
         p->glyph_name = NULL;
@@ -1521,7 +1669,7 @@
 
           glyph           = font->unencoded + font->unencoded_used;
           glyph->name     = p->glyph_name;
-          glyph->encoding = font->unencoded_used++;
+          glyph->encoding = (long)font->unencoded_used++;
 
           /* Reset the initial glyph info. */
           p->glyph_name = NULL;
@@ -1538,16 +1686,13 @@
 
       /* Clear the flags that might be added when width and height are */
       /* checked for consistency.                                      */
-      p->flags &= ~( BDF_GLYPH_WIDTH_CHECK_ | BDF_GLYPH_HEIGHT_CHECK_ );
+      p->flags &= ~( _BDF_GLYPH_WIDTH_CHECK | _BDF_GLYPH_HEIGHT_CHECK );
 
-      p->flags |= BDF_ENCODING_;
+      p->flags |= _BDF_ENCODING;
 
       goto Exit;
     }
 
-    if ( !( p->flags & BDF_ENCODING_ ) )
-      goto Missing_Encoding;
-
     /* Point at the glyph being constructed. */
     if ( p->glyph_enc == -1 )
       glyph = font->unencoded + ( font->unencoded_used - 1 );
@@ -1555,18 +1700,25 @@
       glyph = font->glyphs + ( font->glyphs_used - 1 );
 
     /* Check whether a bitmap is being constructed. */
-    if ( p->flags & BDF_BITMAP_ )
+    if ( p->flags & _BDF_BITMAP )
     {
-      /* If there are more rows than are specified in the glyph metrics, */
-      /* ignore the remaining lines.                                     */
-      if ( p->row >= (unsigned long)glyph->bbx.height )
+      while (1)
       {
-        if ( !( p->flags & BDF_GLYPH_HEIGHT_CHECK_ ) )
+        /* If there are more rows than are specified in the glyph metrics, */
+        /* ignore the remaining lines.                                     */
+        if ( p->row >= (unsigned long)glyph->bbx.height )
         {
-          FT_TRACE2(( "_bdf_parse_glyphs: " ACMSG13, glyph->encoding ));
-          p->flags |= BDF_GLYPH_HEIGHT_CHECK_;
-        }
+          if ( !( p->flags & _BDF_GLYPH_HEIGHT_CHECK ) )
+          {
+            FT_TRACE2(( "_bdf_parse_glyphs: " ACMSG13, glyph->encoding ));
+            p->flags |= _BDF_GLYPH_HEIGHT_CHECK;
+            font->modified = 1;
+          }
 
+          if (p->compact_tag == 1)
+          {
+            p->binary_mode = 0;
+          }
         goto Exit;
       }
 
@@ -1575,66 +1727,88 @@
       nibbles = glyph->bpr << 1;
       bp      = glyph->bitmap + p->row * glyph->bpr;
 
-      for ( i = 0; i < nibbles; i++ )
-      {
-        c = line[i];
-        if ( !sbitset( hdigits, c ) )
-          break;
-        *bp = (FT_Byte)( ( *bp << 4 ) + a2i[c] );
-        if ( i + 1 < nibbles && ( i & 1 ) )
-          *++bp = 0;
-      }
+        if (p->compact_tag == 1)
+        {
+          for ( i = 0, *bp = 0; i < glyph->bpr; i++ )
+          {
+            c = line[i];
 
-      /* If any line has not enough columns,            */
-      /* indicate they have been padded with zero bits. */
-      if ( i < nibbles                            &&
-           !( p->flags & BDF_GLYPH_WIDTH_CHECK_ ) )
-      {
-        FT_TRACE2(( "_bdf_parse_glyphs: " ACMSG16, glyph->encoding ));
-        p->flags       |= BDF_GLYPH_WIDTH_CHECK_;
-      }
+            *bp = (FT_Byte)c;
+            bp = bp + 1;
+          }
+        }
+        else
+        {
+          for ( i = 0, *bp = 0; i < nibbles; i++ )
+          {
+            c = line[i];
 
-      /* Remove possible garbage at the right. */
-      mask_index = ( glyph->bbx.width * p->font->bpp ) & 7;
-      if ( glyph->bbx.width )
-        *bp &= nibble_mask[mask_index];
+            *bp = (FT_Byte)( ( *bp << 4 ) + a2i[c] );
+            if ( i + 1 < nibbles && ( i & 1 ) )
+                *++bp = 0;
+          }
+        }
 
-      /* If any line has extra columns, indicate they have been removed. */
-      if ( i == nibbles                           &&
-           sbitset( hdigits, line[nibbles] )      &&
-           !( p->flags & BDF_GLYPH_WIDTH_CHECK_ ) )
-      {
-        FT_TRACE2(( "_bdf_parse_glyphs: " ACMSG14, glyph->encoding ));
-        p->flags       |= BDF_GLYPH_WIDTH_CHECK_;
-      }
+        if (p->compact_tag == 1)
+        {
+            line += glyph->bpr;
+        }
 
-      p->row++;
-      goto Exit;
+        /* Remove possible garbage at the right. */
+        mask_index = ( glyph->bbx.width * p->font->bpp ) & 7;
+		if (p->row > 0){
+        	bp      = glyph->bitmap + p->row * glyph->bpr - 1;
+        	*bp &= nibble_mask[mask_index];
+		}
+        /* If any line has extra columns, indicate they have been removed. */
+        if ( ( line[nibbles] == '0' || a2i[(int)line[nibbles]] != 0 ) &&
+             !( p->flags & _BDF_GLYPH_WIDTH_CHECK )                   )
+        {
+          FT_TRACE2(( "_bdf_parse_glyphs: " ACMSG14, glyph->encoding ));
+          p->flags       |= _BDF_GLYPH_WIDTH_CHECK;
+          font->modified  = 1;
+        }
+
+        p->row++;
+
+        if (p->compact_tag == 0)
+        {
+            goto Exit;
+        }
+      }
     }
 
     /* Expect the SWIDTH (scalable width) field next. */
-    if ( _bdf_strncmp( line, "SWIDTH", 6 ) == 0 )
+    if ( (p->compact_tag == 1 && ft_memcmp( line, "W", 1 ) == 0) || (p->compact_tag == 0 && ft_memcmp( line, "SWIDTH", 6 ) == 0))
     {
-      error = _bdf_list_split( &p->list, " +", line, linelen );
+      if ( !( p->flags & _BDF_ENCODING ) )
+      {
+        /* Missing ENCODING field. */
+        FT_ERROR(( "_bdf_parse_glyphs: " ERRMSG1, lineno, "ENCODING" ));
+        error = BDF_Err_Missing_Encoding_Field;
+        goto Exit;
+      }
+
+      error = _bdf_list_split( &p->list, (char *)" +", line, linelen );
       if ( error )
         goto Exit;
 
-      glyph->swidth = (unsigned short)_bdf_atoul( p->list.field[1] );
-      p->flags |= BDF_SWIDTH_;
+      glyph->swidth = (unsigned short)_bdf_atoul( p->list.field[1], 0, 10 );
+      p->flags |= _BDF_SWIDTH;
 
       goto Exit;
     }
 
     /* Expect the DWIDTH (scalable width) field next. */
-    if ( _bdf_strncmp( line, "DWIDTH", 6 ) == 0 )
+    if ( (p->compact_tag == 1 && ft_memcmp( line, "D", 1 ) == 0) || (p->compact_tag == 0 && ft_memcmp( line, "DWIDTH", 6 ) == 0))
     {
-      error = _bdf_list_split( &p->list, " +", line, linelen );
+      error = _bdf_list_split( &p->list, (char *)" +", line, linelen );
       if ( error )
         goto Exit;
 
-      glyph->dwidth = (unsigned short)_bdf_atoul( p->list.field[1] );
+      glyph->dwidth = (unsigned short)_bdf_atoul( p->list.field[1], 0, 10 );
 
-      if ( !( p->flags & BDF_SWIDTH_ ) )
+      if ( !( p->flags & _BDF_SWIDTH ) )
       {
         /* Missing SWIDTH field.  Emit an auto correction message and set */
         /* the scalable width from the device width.                      */
@@ -1646,21 +1820,21 @@
                                      font->resolution_x ) );
       }
 
-      p->flags |= BDF_DWIDTH_;
+      p->flags |= _BDF_DWIDTH;
       goto Exit;
     }
 
     /* Expect the BBX field next. */
-    if ( _bdf_strncmp( line, "BBX", 3 ) == 0 )
+    if ( (p->compact_tag == 1 && ft_memcmp( line, "X", 1 ) == 0) || (p->compact_tag == 0 && ft_memcmp( line, "BBX", 3 ) == 0))
     {
-      error = _bdf_list_split( &p->list, " +", line, linelen );
+      error = _bdf_list_split( &p->list, (char *)" +", line, linelen );
       if ( error )
         goto Exit;
 
-      glyph->bbx.width    = _bdf_atous( p->list.field[1] );
-      glyph->bbx.height   = _bdf_atous( p->list.field[2] );
-      glyph->bbx.x_offset = _bdf_atos( p->list.field[3] );
-      glyph->bbx.y_offset = _bdf_atos( p->list.field[4] );
+      glyph->bbx.width    = _bdf_atos( p->list.field[1], 0, 10 );
+      glyph->bbx.height   = _bdf_atos( p->list.field[2], 0, 10 );
+      glyph->bbx.x_offset = _bdf_atos( p->list.field[3], 0, 10 );
+      glyph->bbx.y_offset = _bdf_atos( p->list.field[4], 0, 10 );
 
       /* Generate the ascent and descent of the character. */
       glyph->bbx.ascent  = (short)( glyph->bbx.height + glyph->bbx.y_offset );
@@ -1677,7 +1851,7 @@
       p->minlb    = (short)FT_MIN( glyph->bbx.x_offset, p->minlb );
       p->maxlb    = (short)FT_MAX( glyph->bbx.x_offset, p->maxlb );
 
-      if ( !( p->flags & BDF_DWIDTH_ ) )
+      if ( !( p->flags & _BDF_DWIDTH ) )
       {
         /* Missing DWIDTH field.  Emit an auto correction message and set */
         /* the device width to the glyph width.                           */
@@ -1700,61 +1874,56 @@
         {
           glyph->swidth = sw;
 
-          p->flags       |= BDF_SWIDTH_ADJ_;
+          if ( p->glyph_enc == -1 )
+            _bdf_set_glyph_modified( font->umod,
+                                     font->unencoded_used - 1 );
+          else
+            _bdf_set_glyph_modified( font->nmod, glyph->encoding );
+
+          p->flags       |= _BDF_SWIDTH_ADJ;
+          font->modified  = 1;
         }
       }
 
-      p->flags |= BDF_BBX_;
+      p->flags |= _BDF_BBX;
       goto Exit;
     }
 
     /* And finally, gather up the bitmap. */
-    if ( _bdf_strncmp( line, "BITMAP", 6 ) == 0 )
+    if ( (p->compact_tag == 1 && ft_memcmp( line, "B", 1 ) == 0) || (p->compact_tag == 0 && ft_memcmp( line, "BITMAP", 6 ) == 0))
     {
-      unsigned long  bitmap_size;
-
-
-      if ( !( p->flags & BDF_BBX_ ) )
+      if ( !( p->flags & _BDF_BBX ) )
       {
         /* Missing BBX field. */
         FT_ERROR(( "_bdf_parse_glyphs: " ERRMSG1, lineno, "BBX" ));
-        error = FT_THROW( Missing_Bbx_Field );
+        error = BDF_Err_Missing_Bbx_Field;
         goto Exit;
       }
 
       /* Allocate enough space for the bitmap. */
-      glyph->bpr = ( glyph->bbx.width * p->font->bpp + 7 ) >> 3;
-
-      bitmap_size = glyph->bpr * glyph->bbx.height;
-      if ( glyph->bpr > 0xFFFFU || bitmap_size > 0xFFFFU )
-      {
-        FT_ERROR(( "_bdf_parse_glyphs: " ERRMSG4, lineno ));
-        error = FT_THROW( Bbx_Too_Big );
-        goto Exit;
-      }
-      else
-        glyph->bytes = (unsigned short)bitmap_size;
+      glyph->bpr   = ( glyph->bbx.width * p->font->bpp + 7 ) >> 3;
+      glyph->bytes = (unsigned short)( glyph->bpr * glyph->bbx.height );
 
       if ( FT_NEW_ARRAY( glyph->bitmap, glyph->bytes ) )
         goto Exit;
 
+      if (p->compact_tag == 1)
+      {
+          p->binary_mode  = 1;
+          p->bitmap_bytes = (int)glyph->bytes;
+      }
+
       p->row    = 0;
-      p->flags |= BDF_BITMAP_;
+      p->flags |= _BDF_BITMAP;
 
       goto Exit;
     }
 
-    FT_ERROR(( "_bdf_parse_glyphs: " ERRMSG9, lineno ));
-    error = FT_THROW( Invalid_File_Format );
-    goto Exit;
+    error = BDF_Err_Invalid_File_Format;
 
-  Missing_Encoding:
-    /* Missing ENCODING field. */
-    FT_ERROR(( "_bdf_parse_glyphs: " ERRMSG1, lineno, "ENCODING" ));
-    error = FT_THROW( Missing_Encoding_Field );
 
   Exit:
-    if ( error && ( p->flags & BDF_GLYPH_ ) )
+    if ( error && ( p->flags & _BDF_GLYPH ) )
       FT_FREE( p->glyph_name );
 
     return error;
@@ -1775,7 +1944,7 @@
     char*              name;
     char*              value;
     char               nbuf[128];
-    FT_Error           error = FT_Err_Ok;
+    FT_Error           error = BDF_Err_Ok;
 
     FT_UNUSED( lineno );
 
@@ -1784,7 +1953,7 @@
     p    = (_bdf_parse_t *)    client_data;
 
     /* Check for the end of the properties. */
-    if ( _bdf_strncmp( line, "ENDPROPERTIES", 13 ) == 0 )
+    if ( ft_memcmp( line, "ENDPROPERTIES", 13 ) == 0 )
     {
       /* If the FONT_ASCENT or FONT_DESCENT properties have not been      */
       /* encountered yet, then make sure they are added as properties and */
@@ -1796,57 +1965,57 @@
       {
         p->font->font_ascent = p->font->bbx.ascent;
         ft_sprintf( nbuf, "%hd", p->font->bbx.ascent );
-        error = _bdf_add_property( p->font, "FONT_ASCENT",
-                                   nbuf, lineno );
+        error = _bdf_add_property( p->font, (char *)"FONT_ASCENT", nbuf );
         if ( error )
           goto Exit;
 
         FT_TRACE2(( "_bdf_parse_properties: " ACMSG1, p->font->bbx.ascent ));
+        p->font->modified = 1;
       }
 
       if ( bdf_get_font_property( p->font, "FONT_DESCENT" ) == 0 )
       {
         p->font->font_descent = p->font->bbx.descent;
         ft_sprintf( nbuf, "%hd", p->font->bbx.descent );
-        error = _bdf_add_property( p->font, "FONT_DESCENT",
-                                   nbuf, lineno );
+        error = _bdf_add_property( p->font, (char *)"FONT_DESCENT", nbuf );
         if ( error )
           goto Exit;
 
         FT_TRACE2(( "_bdf_parse_properties: " ACMSG2, p->font->bbx.descent ));
+        p->font->modified = 1;
       }
 
-      p->flags &= ~BDF_PROPS_;
+      p->flags &= ~_BDF_PROPS;
       *next     = _bdf_parse_glyphs;
 
       goto Exit;
     }
 
     /* Ignore the _XFREE86_GLYPH_RANGES properties. */
-    if ( _bdf_strncmp( line, "_XFREE86_GLYPH_RANGES", 21 ) == 0 )
+    if ( ft_memcmp( line, "_XFREE86_GLYPH_RANGES", 21 ) == 0 )
       goto Exit;
 
     /* Handle COMMENT fields and properties in a special way to preserve */
     /* the spacing.                                                      */
-    if ( _bdf_strncmp( line, "COMMENT", 7 ) == 0 )
+    if ( ft_memcmp( line, "COMMENT", 7 ) == 0 )
     {
       name = value = line;
       value += 7;
       if ( *value )
         *value++ = 0;
-      error = _bdf_add_property( p->font, name, value, lineno );
+      error = _bdf_add_property( p->font, name, value );
       if ( error )
         goto Exit;
     }
     else if ( _bdf_is_atom( line, linelen, &name, &value, p->font ) )
     {
-      error = _bdf_add_property( p->font, name, value, lineno );
+      error = _bdf_add_property( p->font, name, value );
       if ( error )
         goto Exit;
     }
     else
     {
-      error = _bdf_list_split( &p->list, " +", line, linelen );
+      error = _bdf_list_split( &p->list, (char *)" +", line, linelen );
       if ( error )
         goto Exit;
       name = p->list.field[0];
@@ -1854,7 +2023,7 @@
       _bdf_list_shift( &p->list, 1 );
       value = _bdf_list_join( &p->list, ' ', &vlen );
 
-      error = _bdf_add_property( p->font, name, value, lineno );
+      error = _bdf_add_property( p->font, name, value );
       if ( error )
         goto Exit;
     }
@@ -1879,7 +2048,7 @@
     char               *s;
 
     FT_Memory          memory = NULL;
-    FT_Error           error  = FT_Err_Ok;
+    FT_Error           error  = BDF_Err_Ok;
 
     FT_UNUSED( lineno );            /* only used in debug mode */
 
@@ -1892,7 +2061,7 @@
 
     /* Check for a comment.  This is done to handle those fonts that have */
     /* comments before the STARTFONT line for some reason.                */
-    if ( _bdf_strncmp( line, "COMMENT", 7 ) == 0 )
+    if ( ft_memcmp( line, "COMMENT", 7 ) == 0 )
     {
       if ( p->opts->keep_comments != 0 && p->font != 0 )
       {
@@ -1914,19 +2083,18 @@
       goto Exit;
     }
 
-    if ( !( p->flags & BDF_START_ ) )
+    if ( !( p->flags & _BDF_START ) )
     {
       memory = p->memory;
 
-      if ( _bdf_strncmp( line, "STARTFONT", 9 ) != 0 )
+      if ( ft_memcmp( line, "STARTFONT", 9 ) != 0 )
       {
-        /* we don't emit an error message since this code gets */
-        /* explicitly caught one level higher                  */
-        error = FT_THROW( Missing_Startfont_Field );
+        /* No STARTFONT field is a good indication of a problem. */
+        error = BDF_Err_Missing_Startfont_Field;
         goto Exit;
       }
 
-      p->flags = BDF_START_;
+      p->flags = _BDF_START;
       font = p->font = 0;
 
       if ( FT_NEW( font ) )
@@ -1937,239 +2105,172 @@
       p->memory    = 0;
 
       { /* setup */
-        size_t           i;
+        unsigned long    i;
         bdf_property_t*  prop;
 
 
-        error = ft_hash_str_init( &(font->proptbl), memory );
+        error = hash_init( &(font->proptbl), memory );
         if ( error )
           goto Exit;
         for ( i = 0, prop = (bdf_property_t*)_bdf_properties;
               i < _num_bdf_properties; i++, prop++ )
         {
-          error = ft_hash_str_insert( prop->name, i,
-                                      &(font->proptbl), memory );
+          error = hash_insert( prop->name, (void *)i,
+                               &(font->proptbl), memory );
           if ( error )
             goto Exit;
         }
       }
 
-      if ( FT_ALLOC( p->font->internal, sizeof ( FT_HashRec ) ) )
+      if ( FT_ALLOC( p->font->internal, sizeof ( hashtable ) ) )
         goto Exit;
-      error = ft_hash_str_init( (FT_Hash)p->font->internal, memory );
+      error = hash_init( (hashtable *)p->font->internal,memory );
       if ( error )
         goto Exit;
       p->font->spacing      = p->opts->font_spacing;
-      p->font->default_char = ~0UL;
+      p->font->default_char = -1;
 
       goto Exit;
     }
 
     /* Check for the start of the properties. */
-    if ( _bdf_strncmp( line, "STARTPROPERTIES", 15 ) == 0 )
+    if ( ft_memcmp( line, "STARTPROPERTIES", 15 ) == 0 )
     {
-      if ( !( p->flags & BDF_FONT_BBX_ ) )
-      {
-        /* Missing the FONTBOUNDINGBOX field. */
-        FT_ERROR(( "_bdf_parse_start: " ERRMSG1, lineno, "FONTBOUNDINGBOX" ));
-        error = FT_THROW( Missing_Fontboundingbox_Field );
-        goto Exit;
-      }
-
-      error = _bdf_list_split( &p->list, " +", line, linelen );
+      error = _bdf_list_split( &p->list, (char *)" +", line, linelen );
       if ( error )
         goto Exit;
-
-      /* at this point, `p->font' can't be NULL */
-      p->cnt = p->font->props_size = _bdf_atoul( p->list.field[1] );
-      /* We need at least 4 bytes per property. */
-      if ( p->cnt > p->size / 4 )
-      {
-        p->font->props_size = 0;
-
-        FT_ERROR(( "_bdf_parse_glyphs: " ERRMSG5, lineno, "STARTPROPERTIES" ));
-        error = FT_THROW( Invalid_Argument );
-        goto Exit;
-      }
+      p->cnt = p->font->props_size = _bdf_atoul( p->list.field[1], 0, 10 );
 
       if ( FT_NEW_ARRAY( p->font->props, p->cnt ) )
-      {
-        p->font->props_size = 0;
         goto Exit;
-      }
 
-      p->flags |= BDF_PROPS_;
+      p->flags |= _BDF_PROPS;
       *next     = _bdf_parse_properties;
 
       goto Exit;
     }
 
     /* Check for the FONTBOUNDINGBOX field. */
-    if ( _bdf_strncmp( line, "FONTBOUNDINGBOX", 15 ) == 0 )
+    if ( ft_memcmp( line, "FONTBOUNDINGBOX", 15 ) == 0 )
     {
-      if ( !( p->flags & BDF_SIZE_ ) )
+      if ( !(p->flags & _BDF_SIZE ) )
       {
         /* Missing the SIZE field. */
         FT_ERROR(( "_bdf_parse_start: " ERRMSG1, lineno, "SIZE" ));
-        error = FT_THROW( Missing_Size_Field );
+        error = BDF_Err_Missing_Size_Field;
         goto Exit;
       }
 
-      error = _bdf_list_split( &p->list, " +", line, linelen );
+      error = _bdf_list_split( &p->list, (char *)" +", line, linelen );
       if ( error )
         goto Exit;
 
-      p->font->bbx.width  = _bdf_atous( p->list.field[1] );
-      p->font->bbx.height = _bdf_atous( p->list.field[2] );
+      p->font->bbx.width  = _bdf_atos( p->list.field[1], 0, 10 );
+      p->font->bbx.height = _bdf_atos( p->list.field[2], 0, 10 );
 
-      p->font->bbx.x_offset = _bdf_atos( p->list.field[3] );
-      p->font->bbx.y_offset = _bdf_atos( p->list.field[4] );
+      p->font->bbx.x_offset = _bdf_atos( p->list.field[3], 0, 10 );
+      p->font->bbx.y_offset = _bdf_atos( p->list.field[4], 0, 10 );
 
       p->font->bbx.ascent  = (short)( p->font->bbx.height +
                                       p->font->bbx.y_offset );
 
       p->font->bbx.descent = (short)( -p->font->bbx.y_offset );
 
-      p->flags |= BDF_FONT_BBX_;
+      p->flags |= _BDF_FONT_BBX;
 
       goto Exit;
     }
 
     /* The next thing to check for is the FONT field. */
-    if ( _bdf_strncmp( line, "FONT", 4 ) == 0 )
+    if ( ft_memcmp( line, "FONT", 4 ) == 0 )
     {
-      error = _bdf_list_split( &p->list, " +", line, linelen );
+      error = _bdf_list_split( &p->list, (char *)" +", line, linelen );
       if ( error )
         goto Exit;
       _bdf_list_shift( &p->list, 1 );
 
       s = _bdf_list_join( &p->list, ' ', &slen );
-
-      if ( !s )
-      {
-        FT_ERROR(( "_bdf_parse_start: " ERRMSG8, lineno, "FONT" ));
-        error = FT_THROW( Invalid_File_Format );
-        goto Exit;
-      }
-
-      /* Allowing multiple `FONT' lines (which is invalid) doesn't hurt... */
-      FT_FREE( p->font->name );
-
       if ( FT_NEW_ARRAY( p->font->name, slen + 1 ) )
         goto Exit;
       FT_MEM_COPY( p->font->name, s, slen + 1 );
 
       /* If the font name is an XLFD name, set the spacing to the one in  */
       /* the font name.  If there is no spacing fall back on the default. */
-      error = _bdf_set_default_spacing( p->font, p->opts, lineno );
+      error = _bdf_set_default_spacing( p->font, p->opts, lineno);
       if ( error )
         goto Exit;
 
-      p->flags |= BDF_FONT_NAME_;
+      p->flags |= _BDF_FONT_NAME;
 
       goto Exit;
     }
 
     /* Check for the SIZE field. */
-    if ( _bdf_strncmp( line, "SIZE", 4 ) == 0 )
+    if ( ft_memcmp( line, "SIZE", 4 ) == 0 )
     {
-      if ( !( p->flags & BDF_FONT_NAME_ ) )
+      if ( !( p->flags & _BDF_FONT_NAME ) )
       {
         /* Missing the FONT field. */
         FT_ERROR(( "_bdf_parse_start: " ERRMSG1, lineno, "FONT" ));
-        error = FT_THROW( Missing_Font_Field );
+        error = BDF_Err_Missing_Font_Field;
         goto Exit;
       }
 
-      error = _bdf_list_split( &p->list, " +", line, linelen );
+      error = _bdf_list_split( &p->list, (char *)" +", line, linelen );
       if ( error )
         goto Exit;
 
-      p->font->point_size   = _bdf_atoul( p->list.field[1] );
-      p->font->resolution_x = _bdf_atoul( p->list.field[2] );
-      p->font->resolution_y = _bdf_atoul( p->list.field[3] );
+      p->font->point_size   = _bdf_atoul( p->list.field[1], 0, 10 );
+      p->font->resolution_x = _bdf_atoul( p->list.field[2], 0, 10 );
+      p->font->resolution_y = _bdf_atoul( p->list.field[3], 0, 10 );
 
       /* Check for the bits per pixel field. */
       if ( p->list.used == 5 )
       {
-        unsigned short bpp;
+        unsigned short bitcount, i, shift;
 
 
-        bpp = (unsigned short)_bdf_atos( p->list.field[4] );
+        p->font->bpp = (unsigned short)_bdf_atos( p->list.field[4], 0, 10 );
 
-        /* Only values 1, 2, 4, 8 are allowed for greymap fonts. */
-        if ( bpp > 4 )
-          p->font->bpp = 8;
-        else if ( bpp > 2 )
-          p->font->bpp = 4;
-        else if ( bpp > 1 )
-          p->font->bpp = 2;
-        else
-          p->font->bpp = 1;
+        /* Only values 1, 2, 4, 8 are allowed. */
+        shift = p->font->bpp;
+        bitcount = 0;
+        for ( i = 0; shift > 0; i++ )
+        {
+          if ( shift & 1 )
+            bitcount = i;
+          shift >>= 1;
+        }
 
-        if ( p->font->bpp != bpp )
+        shift = (short)( ( bitcount > 3 ) ? 8 : ( 1 << bitcount ) );
+
+        if ( p->font->bpp > shift || p->font->bpp != shift )
+        {
+          /* select next higher value */
+          p->font->bpp = (unsigned short)( shift << 1 );
           FT_TRACE2(( "_bdf_parse_start: " ACMSG11, p->font->bpp ));
+        }
       }
       else
         p->font->bpp = 1;
 
-      p->flags |= BDF_SIZE_;
-
-      goto Exit;
-    }
-
-    /* Check for the CHARS field -- font properties are optional */
-    if ( _bdf_strncmp( line, "CHARS", 5 ) == 0 )
-    {
-      char  nbuf[128];
-
-
-      if ( !( p->flags & BDF_FONT_BBX_ ) )
-      {
-        /* Missing the FONTBOUNDINGBOX field. */
-        FT_ERROR(( "_bdf_parse_start: " ERRMSG1, lineno, "FONTBOUNDINGBOX" ));
-        error = FT_THROW( Missing_Fontboundingbox_Field );
-        goto Exit;
-      }
-
-      /* Add the two standard X11 properties which are required */
-      /* for compiling fonts.                                   */
-      p->font->font_ascent = p->font->bbx.ascent;
-      ft_sprintf( nbuf, "%hd", p->font->bbx.ascent );
-      error = _bdf_add_property( p->font, "FONT_ASCENT",
-                                 nbuf, lineno );
-      if ( error )
-        goto Exit;
-      FT_TRACE2(( "_bdf_parse_properties: " ACMSG1, p->font->bbx.ascent ));
-
-      p->font->font_descent = p->font->bbx.descent;
-      ft_sprintf( nbuf, "%hd", p->font->bbx.descent );
-      error = _bdf_add_property( p->font, "FONT_DESCENT",
-                                 nbuf, lineno );
-      if ( error )
-        goto Exit;
-      FT_TRACE2(( "_bdf_parse_properties: " ACMSG2, p->font->bbx.descent ));
-
-      *next = _bdf_parse_glyphs;
+      p->flags |= _BDF_SIZE;
 
-      /* A special return value. */
-      error = -1;
       goto Exit;
     }
 
-    FT_ERROR(( "_bdf_parse_start: " ERRMSG9, lineno ));
-    error = FT_THROW( Invalid_File_Format );
+    error = BDF_Err_Invalid_File_Format;
 
   Exit:
     return error;
   }
 
 
-  /**************************************************************************
-   *
-   * API.
-   *
-   */
+  /*************************************************************************/
+  /*                                                                       */
+  /* API.                                                                  */
+  /*                                                                       */
+  /*************************************************************************/
 
 
   FT_LOCAL_DEF( FT_Error )
@@ -2178,11 +2279,11 @@
                  bdf_options_t*  opts,
                  bdf_font_t*    *font )
   {
-    unsigned long  lineno = 0; /* make compiler happy */
-    _bdf_parse_t   *p     = NULL;
+    unsigned long  lineno;
+    _bdf_parse_t   *p;
 
-    FT_Memory  memory = extmemory; /* needed for FT_NEW */
-    FT_Error   error  = FT_Err_Ok;
+    FT_Memory      memory = extmemory;
+    FT_Error       error  = BDF_Err_Ok;
 
 
     if ( FT_NEW( p ) )
@@ -2191,20 +2292,22 @@
     memory    = NULL;
     p->opts   = (bdf_options_t*)( ( opts != 0 ) ? opts : &_bdf_opts );
     p->minlb  = 32767;
-    p->size   = stream->size;
     p->memory = extmemory;  /* only during font creation */
+    p->binary_mode = 0;
+    p->compact_tag = 0;
 
     _bdf_list_init( &p->list, extmemory );
 
     error = _bdf_readstream( stream, _bdf_parse_start,
                              (void *)p, &lineno );
     if ( error )
-      goto Fail;
+      goto Exit;
 
     if ( p->font != 0 )
     {
       /* If the font is not proportional, set the font's monowidth */
       /* field to the width of the font bounding box.              */
+      memory = p->font->memory;
 
       if ( p->font->spacing != BDF_PROPORTIONAL )
         p->font->monowidth = p->font->bbx.width;
@@ -2215,6 +2318,7 @@
       {
         FT_TRACE2(( "bdf_load_font: " ACMSG15, p->cnt,
                     p->font->glyphs_used + p->font->unencoded_used ));
+        p->font->modified = 1;
       }
 
       /* Once the font has been loaded, adjust the overall font metrics if */
@@ -2227,6 +2331,7 @@
           FT_TRACE2(( "bdf_load_font: " ACMSG3,
                       p->font->bbx.width, p->maxrb - p->minlb ));
           p->font->bbx.width = (unsigned short)( p->maxrb - p->minlb );
+          p->font->modified  = 1;
         }
 
         if ( p->font->bbx.x_offset != p->minlb )
@@ -2234,6 +2339,7 @@
           FT_TRACE2(( "bdf_load_font: " ACMSG4,
                       p->font->bbx.x_offset, p->minlb ));
           p->font->bbx.x_offset = p->minlb;
+          p->font->modified     = 1;
         }
 
         if ( p->font->bbx.ascent != p->maxas )
@@ -2241,6 +2347,7 @@
           FT_TRACE2(( "bdf_load_font: " ACMSG5,
                       p->font->bbx.ascent, p->maxas ));
           p->font->bbx.ascent = p->maxas;
+          p->font->modified   = 1;
         }
 
         if ( p->font->bbx.descent != p->maxds )
@@ -2249,6 +2356,7 @@
                       p->font->bbx.descent, p->maxds ));
           p->font->bbx.descent  = p->maxds;
           p->font->bbx.y_offset = (short)( -p->maxds );
+          p->font->modified     = 1;
         }
 
         if ( p->maxas + p->maxds != p->font->bbx.height )
@@ -2258,27 +2366,21 @@
           p->font->bbx.height = (unsigned short)( p->maxas + p->maxds );
         }
 
-        if ( p->flags & BDF_SWIDTH_ADJ_ )
+        if ( p->flags & _BDF_SWIDTH_ADJ )
           FT_TRACE2(( "bdf_load_font: " ACMSG8 ));
       }
     }
 
-    if ( p->flags & BDF_START_ )
+    if ( p->flags & _BDF_START )
     {
-      /* The ENDFONT field was never reached or did not exist. */
-      if ( !( p->flags & BDF_GLYPHS_ ) )
       {
-        /* Error happened while parsing header. */
-        FT_ERROR(( "bdf_load_font: " ERRMSG2, lineno ));
-        error = FT_THROW( Corrupted_Font_Header );
-        goto Fail;
-      }
-      else
-      {
-        /* Error happened when parsing glyphs. */
-        FT_ERROR(( "bdf_load_font: " ERRMSG3, lineno ));
-        error = FT_THROW( Corrupted_Font_Glyphs );
-        goto Fail;
+        /* The ENDFONT field was never reached or did not exist. */
+        if ( !( p->flags & _BDF_GLYPHS ) )
+          /* Error happened while parsing header. */
+          FT_ERROR(( "bdf_load_font: " ERRMSG2, lineno ));
+        else
+          /* Error happened when parsing glyphs. */
+          FT_ERROR(( "bdf_load_font: " ERRMSG3, lineno ));
       }
     }
 
@@ -2287,18 +2389,17 @@
       /* Make sure the comments are NULL terminated if they exist. */
       memory = p->font->memory;
 
-      if ( p->font->comments_len > 0 )
-      {
+      if ( p->font->comments_len > 0 ) {
         if ( FT_RENEW_ARRAY( p->font->comments,
                              p->font->comments_len,
                              p->font->comments_len + 1 ) )
-          goto Fail;
+          goto Exit;
 
         p->font->comments[p->font->comments_len] = 0;
       }
     }
-    else if ( !error )
-      error = FT_THROW( Invalid_File_Format );
+    else if ( error == BDF_Err_Ok )
+      error = BDF_Err_Invalid_File_Format;
 
     *font = p->font;
 
@@ -2345,7 +2446,7 @@
     /* Free up the internal hash table of property names. */
     if ( font->internal )
     {
-      ft_hash_str_free( (FT_Hash)font->internal, memory );
+      hash_free( (hashtable *)font->internal, memory );
       FT_FREE( font->internal );
     }
 
@@ -2379,12 +2480,22 @@
     FT_FREE( font->glyphs );
     FT_FREE( font->unencoded );
 
+    /* Free up the overflow storage if it was used. */
+    for ( i = 0, glyphs = font->overflow.glyphs;
+          i < font->overflow.glyphs_used; i++, glyphs++ )
+    {
+      FT_FREE( glyphs->name );
+      FT_FREE( glyphs->bitmap );
+    }
+
+    FT_FREE( font->overflow.glyphs );
+
     /* bdf_cleanup */
-    ft_hash_str_free( &(font->proptbl), memory );
+    hash_free( &(font->proptbl), memory );
 
     /* Free up the user defined properties. */
-    for ( prop = font->user_props, i = 0;
-          i < font->nuser_props; i++, prop++ )
+    for (prop = font->user_props, i = 0;
+         i < font->nuser_props; i++, prop++ )
     {
       FT_FREE( prop->name );
       if ( prop->format == BDF_ATOM )
@@ -2401,15 +2512,15 @@
   bdf_get_font_property( bdf_font_t*  font,
                          const char*  name )
   {
-    size_t*  propid;
+    hashnode  hn;
 
 
     if ( font == 0 || font->props_size == 0 || name == 0 || *name == 0 )
       return 0;
 
-    propid = ft_hash_str_lookup( name, (FT_Hash)font->internal );
+    hn = hash_lookup( name, (hashtable *)font->internal );
 
-    return propid ? ( font->props + *propid ) : 0;
+    return hn ? ( font->props + (unsigned long)hn->data ) : 0;
   }
 
 
